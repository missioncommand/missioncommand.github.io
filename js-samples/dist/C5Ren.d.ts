// Generated by dts-bundle-generator v9.5.1

export type int = number;
export type float = number;
export type double = number;
declare class POINT2 {
	x: double;
	y: double;
	style: int;
	segment: int;
	constructor();
	constructor(pt: POINT2);
	constructor(x: double, y: double);
	constructor(x: double, y: double, style: int);
	constructor(x: double, y: double, segment: int, style: int);
	getX(): number;
	getY(): number;
}
/**
 * The <code>Point2D</code> class defines a point representing a location in
 *
 * <p>
 * This class is only the abstract superclass for all objects that store a 2D
 * coordinate. The actual storage representation of the coordinates is left to
 * the subclass.
 *
 * @author Jim Graham
 * @since 1.2
 */
export declare class Point2D {
	/**
	 * The X coordinate of this <code>Point2D</code>.
	 *
	 * @since 1.2
	 */
	x: double;
	/**
	 * The Y coordinate of this <code>Point2D</code>.
	 *
	 * @since 1.2
	 */
	y: double;
	/**
	 * Constructs and initializes a <code>Point2D</code> with coordinates
	 * (0,&nbsp;0).
	 *
	 * @since 1.2
	 */
	constructor();
	/**
	 * add the constructor
	 * @param pt
	 */
	constructor(pt: POINT2);
	/**
	 * Constructs and initializes a <code>Point2D</code> with the specified
	 * coordinates.
	 *
	 * @param x
	 * the X coordinate of the newly constructed
	 * <code>Point2D</code>
	 * @param y
	 * the Y coordinate of the newly constructed
	 * <code>Point2D</code>
	 * @since 1.2
	 */
	constructor(x: double, y: double);
	/**
	 * {@inheritDoc}
	 *
	 * @since 1.2
	 */
	getX(): double;
	/**
	 * {@inheritDoc}
	 *
	 * @since 1.2
	 */
	getY(): double;
	/**
	 * Returns a <code>String</code> that represents the value of this
	 * <code>Point2D</code>.
	 *
	 * @return a string representation of this <code>Point2D</code>.
	 * @since 1.2
	 */
	toString(): string;
	clone(): Point2D;
	private static readonly serialVersionUID;
	/**
	 * Sets the location of this <code>Point2D</code> to the same coordinates as
	 * the specified <code>Point2D</code> object.
	 *
	 * @param p
	 * the specified <code>Point2D</code> to which to set this
	 * <code>Point2D</code>
	 * @since 1.2
	 */
	setLocation(p: Point2D): void;
	/**
	 * Sets the location of this <code>Point2D</code> to the specified
	 * <code>double</code> coordinates.
	 *
	 * @param x
	 * the new X coordinate of this {Point2D}
	 * @param y
	 * the new Y coordinate of this {Point2D}
	 * @since 1.2
	 */
	setLocation(x: double, y: double): void;
	/**
	 * Returns the square of the distance between two points.
	 *
	 * @param x1
	 * the X coordinate of the first specified point
	 * @param y1
	 * the Y coordinate of the first specified point
	 * @param x2
	 * the X coordinate of the second specified point
	 * @param y2
	 * the Y coordinate of the second specified point
	 * @return the square of the distance between the two sets of specified
	 * coordinates.
	 * @since 1.2
	 */
	static distanceSq(x1: double, y1: double, x2: double, y2: double): double;
	/**
	 * Returns the distance between two points.
	 *
	 * @param x1
	 * the X coordinate of the first specified point
	 * @param y1
	 * the Y coordinate of the first specified point
	 * @param x2
	 * the X coordinate of the second specified point
	 * @param y2
	 * the Y coordinate of the second specified point
	 * @return the distance between the two sets of specified coordinates.
	 * @since 1.2
	 */
	static distance(x1: double, y1: double, x2: double, y2: double): double;
	/**
	 * Returns the distance from this <code>Point2D</code> to
	 * a specified point.
	 *
	 * @param px the X coordinate of the specified point to be measured
	 *           against this <code>Point2D</code>
	 * @param py the Y coordinate of the specified point to be measured
	 *           against this <code>Point2D</code>
	 * @return the distance between this <code>Point2D</code>
	 * and a specified point.
	 * @since 1.2
	 */
	distance(px: double, py: double): number;
	/**
	 * Determines whether or not two points are equal. Two instances of
	 * <code>Point2D</code> are equal if the values of their <code>x</code> and
	 * <code>y</code> member fields, representing their position in the
	 * coordinate space, are the same.
	 *
	 * @param obj
	 * an object to be compared with this <code>Point2D</code>
	 * @return <code>true</code> if the object to be compared is an instance of
	 * <code>Point2D</code> and has the same values; <code>false</code>
	 * otherwise.
	 * @since 1.2
	 */
	equals(obj: Point2D): boolean;
}
/**
 *
 *
 */
export declare class Point {
	x: number;
	y: number;
	constructor();
	constructor(x1: number, y1: number);
	getX(): number;
	getY(): number;
	setLocation(x1: number, y1: number): void;
	/**
	 * Returns a string representing one of the shape types
	 * from "armyc2.c2sd.renderer.so.ShapeTypes"
	 * @returns {String}
	 */
	getShapeType(): string;
	/**
	 * move x & y by specified amounts.
	 * @param {Number} x shift x point by this value
	 * @param {Number} y shift y point by this value
	 * @returns {void}
	 */
	shift(x: number, y: number): void;
	/**
	 * @returns {String} like "{x:#,y:#}"
	 */
	toStringFormatted(): string;
	/**
	 * Makes a copy of this point object.
	 * @returns {armyc2.c2sd.renderer.so.Point} Copy of original point.
	 */
	clone(): Point;
	toPoint2D(): Point2D;
	/**
	 * @param {OffscreenCanvasRenderingContext2D} context object from html5 canvas
	 * @returns {void}
	 */
	setPath(context: OffscreenCanvasRenderingContext2D): void;
	/**
	 * @param {context} context object from html5 canvas
	 * @returns {void}
	 */
	stroke(context: OffscreenCanvasRenderingContext2D): void;
	/**
	 * @param {context} context object from html5 canvas
	 * @returns {void}
	 */
	fill(context: OffscreenCanvasRenderingContext2D): void;
}
declare class Line2D {
	intersectsLine(edge: Line2D): boolean;
	static linesIntersect(x1: double, y1: double, x2: double, y2: double, x3: double, y3: double, x4: double, y4: double): boolean;
	/**
	 * The X coordinate of the start point of the line segment.
	 *
	 * @since 1.2
	 * @serial
	 */
	x1: double;
	/**
	 * The Y coordinate of the start point of the line segment.
	 *
	 * @since 1.2
	 * @serial
	 */
	y1: double;
	/**
	 * The X coordinate of the end point of the line segment.
	 *
	 * @since 1.2
	 * @serial
	 */
	x2: double;
	/**
	 * The Y coordinate of the end point of the line segment.
	 *
	 * @since 1.2
	 * @serial
	 */
	y2: double;
	/**
	 * Constructs and initializes a Line with coordinates (0, 0) -&gt; (0, 0).
	 *
	 * @since 1.2
	 */
	constructor();
	/**
	 * Constructs and initializes a <code>Line2D</code> from the specified
	 * <code>Point2D</code> objects.
	 *
	 * @param p1
	 * the start <code>Point2D</code> of this line segment
	 * @param p2
	 * the end <code>Point2D</code> of this line segment
	 * @since 1.2
	 */
	constructor(p1: Point2D, p2: Point2D);
	/**
	 * Constructs and initializes a <code>Line2D</code> from the specified
	 * coordinates.
	 *
	 * @param x1
	 * the X coordinate of the start point
	 * @param y1
	 * the Y coordinate of the start point
	 * @param x2
	 * the X coordinate of the end point
	 * @param y2
	 * the Y coordinate of the end point
	 * @since 1.2
	 */
	constructor(x1: double, y1: double, x2: double, y2: double);
	/**
	 * {@inheritDoc}
	 *
	 * @since 1.2
	 */
	getX1(): double;
	/**
	 * {@inheritDoc}
	 *
	 * @since 1.2
	 */
	getY1(): double;
	/**
	 * {@inheritDoc}
	 *
	 * @since 1.2
	 */
	getP1(): Point2D;
	/**
	 * {@inheritDoc}
	 *
	 * @since 1.2
	 */
	getX2(): double;
	/**
	 * {@inheritDoc}
	 *
	 * @since 1.2
	 */
	getY2(): double;
	/**
	 * {@inheritDoc}
	 *
	 * @since 1.2
	 */
	getP2(): Point2D;
	/**
	 * {@inheritDoc}
	 *
	 * @since 1.2
	 */
	getBounds2D(): Rectangle2D;
	private static readonly serialVersionUID;
	/**
	 * Sets the location of the end points of this <code>Line2D</code> to the
	 * same as those end points of the specified <code>Line2D</code>.
	 *
	 * @param l
	 * the specified <code>Line2D</code>
	 * @since 1.2
	 */
	setLine(l: Line2D): void;
	/**
	 * Sets the location of the end points of this <code>Line2D</code> to the
	 * specified <code>Point2D</code> coordinates.
	 *
	 * @param p1
	 * the start <code>Point2D</code> of the line segment
	 * @param p2
	 * the end <code>Point2D</code> of the line segment
	 * @since 1.2
	 */
	setLine(p1: Point2D, p2: Point2D): void;
	/**
	 * Sets the location of the end points of this <code>Line2D</code> to the
	 * specified double coordinates.
	 *
	 * @param x1
	 * the X coordinate of the start point
	 * @param y1
	 * the Y coordinate of the start point
	 * @param x2
	 * the X coordinate of the end point
	 * @param y2
	 * the Y coordinate of the end point
	 * @since 1.2
	 */
	setLine(x1: double, y1: double, x2: double, y2: double): void;
	/**
	 * Returns an indicator of where the specified point {@code (px,py)} lies
	 * with respect to the line segment from {@code (x1,y1)} to {@code (x2,y2)}.
	 * The return value can be either 1, -1, or 0 and indicates in which
	 * direction the specified line must pivot around its first end point,
	 * {@code (x1,y1)}, in order to point at the specified point {@code (px,py)}
	 * .
	 * <p>
	 * A return value of 1 indicates that the line segment must turn in the
	 * direction that takes the positive X axis towards the negative Y axis. In
	 * the default coordinate system used by Java 2D, this direction is
	 * counterclockwise.
	 * <p>
	 * A return value of -1 indicates that the line segment must turn in the
	 * direction that takes the positive X axis towards the positive Y axis. In
	 * the default coordinate system, this direction is clockwise.
	 * <p>
	 * A return value of 0 indicates that the point lies exactly on the line
	 * segment. Note that an indicator value of 0 is rare and not useful for
	 * determining colinearity because of floating point rounding issues.
	 * <p>
	 * If the point is colinear with the line segment, but not between the end
	 * points, then the value will be -1 if the point lies "beyond {@code
	 * (x1,y1)}" or 1 if the point lies "beyond {@code (x2,y2)}".
	 *
	 * @param x1
	 * the X coordinate of the start point of the specified line
	 * segment
	 * @param y1
	 * the Y coordinate of the start point of the specified line
	 * segment
	 * @param x2
	 * the X coordinate of the end point of the specified line
	 * segment
	 * @param y2
	 * the Y coordinate of the end point of the specified line
	 * segment
	 * @param px
	 * the X coordinate of the specified point to be compared with
	 * the specified line segment
	 * @param py
	 * the Y coordinate of the specified point to be compared with
	 * the specified line segment
	 * @return an integer that indicates the position of the third specified
	 * coordinates with respect to the line segment formed by the first
	 * two specified coordinates.
	 * @since 1.2
	 */
	static relativeCCW(x1: double, y1: double, x2: double, y2: double, px: double, py: double): int;
	/**
	 * Returns an indicator of where the specified point {@code (px,py)} lies
	 * with respect to this line segment. See the method comments of
	 * {@link #relativeCCW(double, double, double, double, double, double)} to
	 * interpret the return value.
	 *
	 * @param px
	 * the X coordinate of the specified point to be compared with
	 * this <code>Line2D</code>
	 * @param py
	 * the Y coordinate of the specified point to be compared with
	 * this <code>Line2D</code>
	 * @return an integer that indicates the position of the specified
	 * coordinates with respect to this <code>Line2D</code>
	 * @see #relativeCCW(double, double, double, double, double, double)
	 * @since 1.2
	 */
	relativeCCW(px: double, py: double): int;
	/**
	 * Returns the square of the distance from a point to a line. The distance
	 * measured is the distance between the specified point and the closest
	 * point on the infinitely-extended line defined by the specified
	 * coordinates. If the specified point intersects the line, this method
	 * returns 0.0.
	 *
	 * @param x1
	 * the X coordinate of the start point of the specified line
	 * @param y1
	 * the Y coordinate of the start point of the specified line
	 * @param x2
	 * the X coordinate of the end point of the specified line
	 * @param y2
	 * the Y coordinate of the end point of the specified line
	 * @param px
	 * the X coordinate of the specified point being measured against
	 * the specified line
	 * @param py
	 * the Y coordinate of the specified point being measured against
	 * the specified line
	 * @return a double value that is the square of the distance from the
	 * specified point to the specified line.
	 * @since 1.2
	 */
	static ptLineDistSq(x1: double, y1: double, x2: double, y2: double, px: double, py: double): double;
	/**
	 * Returns the distance from a point to a line. The distance measured is the
	 * distance between the specified point and the closest point on the
	 * infinitely-extended line defined by the specified coordinates. If the
	 * specified point intersects the line, this method returns 0.0.
	 *
	 * @param x1
	 * the X coordinate of the start point of the specified line
	 * @param y1
	 * the Y coordinate of the start point of the specified line
	 * @param x2
	 * the X coordinate of the end point of the specified line
	 * @param y2
	 * the Y coordinate of the end point of the specified line
	 * @param px
	 * the X coordinate of the specified point being measured against
	 * the specified line
	 * @param py
	 * the Y coordinate of the specified point being measured against
	 * the specified line
	 * @return a double value that is the distance from the specified point to
	 * the specified line.
	 * @since 1.2
	 */
	static ptLineDist(x1: double, y1: double, x2: double, y2: double, px: double, py: double): double;
	/**
	 * Returns the square of the distance from a specified <code>Point2D</code>
	 * to this line. The distance measured is the distance between the specified
	 * point and the closest point on the infinitely-extended line defined by
	 * this <code>Line2D</code>. If the specified point intersects the line,
	 * this method returns 0.0.
	 *
	 * @param pt
	 * the specified <code>Point2D</code> being measured against this
	 * line
	 * @return a double value that is the square of the distance from a
	 * specified <code>Point2D</code> to the current line.
	 * @since 1.2
	 */
	ptLineDistSq(pt: Point2D): double;
	/**
	 * Returns the square of the distance from a point to this line. The
	 * distance measured is the distance between the specified point and the
	 * closest point on the infinitely-extended line defined by this
	 * <code>Line2D</code>. If the specified point intersects the line, this
	 * method returns 0.0.
	 *
	 * @param px
	 * the X coordinate of the specified point being measured against
	 * this line
	 * @param py
	 * the Y coordinate of the specified point being measured against
	 * this line
	 * @return a double value that is the square of the distance from a
	 * specified point to the current line.
	 * @since 1.2
	 */
	ptLineDistSq(px: double, py: double): double;
	/**
	 * Returns the distance from a <code>Point2D</code> to this line. The
	 * distance measured is the distance between the specified point and the
	 * closest point on the infinitely-extended line defined by this
	 * <code>Line2D</code>. If the specified point intersects the line, this
	 * method returns 0.0.
	 *
	 * @param pt
	 * the specified <code>Point2D</code> being measured
	 * @return a double value that is the distance from a specified
	 * <code>Point2D</code> to the current line.
	 * @since 1.2
	 */
	ptLineDist(pt: Point2D): double;
	/**
	 * Returns the distance from a point to this line. The distance measured is
	 * the distance between the specified point and the closest point on the
	 * infinitely-extended line defined by this <code>Line2D</code>. If the
	 * specified point intersects the line, this method returns 0.0.
	 *
	 * @param px
	 * the X coordinate of the specified point being measured against
	 * this line
	 * @param py
	 * the Y coordinate of the specified point being measured against
	 * this line
	 * @return a double value that is the distance from a specified point to the
	 * current line.
	 * @since 1.2
	 */
	ptLineDist(px: double, py: double): double;
	/**
	 * Tests if a given <code>Point2D</code> is inside the boundary of this
	 * <code>Line2D</code>. This method is required to implement the
	 * {@link Shape} interface, but in the case of <code>Line2D</code> objects
	 * it always returns <code>false</code> since a line contains no area.
	 *
	 * @param p
	 * the specified <code>Point2D</code> to be tested
	 * @return <code>false</code> because a <code>Line2D</code> contains no
	 * area.
	 * @since 1.2
	 */
	contains(p: Point2D): boolean;
	/**
	 * Tests if the interior of this <code>Line2D</code> entirely contains the
	 * specified <code>Rectangle2D</code>. This method is required to implement
	 * the <code>Shape</code> interface, but in the case of <code>Line2D</code>
	 * objects it always returns <code>false</code> since a line contains no
	 * area.
	 *
	 * @param r
	 * the specified <code>Rectangle2D</code> to be tested
	 * @return <code>false</code> because a <code>Line2D</code> contains no
	 * area.
	 * @since 1.2
	 */
	contains(r: Rectangle2D): boolean;
	/**
	 * Tests if a specified coordinate is inside the boundary of this
	 * <code>Line2D</code>. This method is required to implement the
	 * {@link Shape} interface, but in the case of <code>Line2D</code> objects
	 * it always returns <code>false</code> since a line contains no area.
	 *
	 * @param x
	 * the X coordinate of the specified point to be tested
	 * @param y
	 * the Y coordinate of the specified point to be tested
	 * @return <code>false</code> because a <code>Line2D</code> contains no
	 * area.
	 * @since 1.2
	 */
	contains(x: double, y: double): boolean;
	/**
	 * Tests if the interior of this <code>Line2D</code> entirely contains the
	 * specified set of rectangular coordinates. This method is required to
	 * implement the <code>Shape</code> interface, but in the case of
	 * <code>Line2D</code> objects it always returns false since a line contains
	 * no area.
	 *
	 * @param x
	 * the X coordinate of the upper-left corner of the specified
	 * rectangular area
	 * @param y
	 * the Y coordinate of the upper-left corner of the specified
	 * rectangular area
	 * @param w
	 * the width of the specified rectangular area
	 * @param h
	 * the height of the specified rectangular area
	 * @return <code>false</code> because a <code>Line2D</code> contains no
	 * area.
	 * @since 1.2
	 */
	contains(x: double, y: double, w: double, h: double): boolean;
	/**
	 * Creates a new object of the same class as this object.
	 *
	 * @return a clone of this instance.
	 * @exception OutOfMemoryError
	 * if there is not enough memory.
	 * @see java.lang.Cloneable
	 * @since 1.2
	 */
	clone(): Line2D | null;
}
/**
 *
 *
 */
export declare class Rectangle2D {
	x: double;
	y: double;
	width: double;
	height: double;
	add(newx: double, newy: double): void;
	createIntersection(r: Rectangle2D): Rectangle2D | null;
	createUnion(r: Rectangle2D): Rectangle2D;
	getX(): double;
	getY(): double;
	getCenterX(): double;
	getCenterY(): double;
	getMinX(): double;
	getMinY(): double;
	getMaxX(): double;
	getMaxY(): double;
	getHeight(): double;
	getWidth(): double;
	contains(rect: Rectangle2D): boolean;
	contains(pt: Point2D): boolean;
	contains(x1: double, y1: double): boolean;
	contains(x: int, y: int, width: int, height: int): boolean;
	intersects(rect: Rectangle2D): boolean;
	intersects(x1: int, y1: int, width1: int, height1: int): boolean;
	intersectsLine(line: Line2D): boolean;
	isEmpty(): boolean;
	setRect(r: Rectangle2D): void;
	setRect(x1: double, y1: double, width1: double, height1: double): void;
	grow(size: int): any;
	grow(h: int, v: int): any;
	stroke(context: OffscreenCanvasRenderingContext2D): void;
	fill(context: OffscreenCanvasRenderingContext2D): void;
	clone(): Rectangle2D;
	/**
	 * Will merge the bounds of two rectangle.
	 * @param rect
	 */
	union(rect: Rectangle2D): void;
	constructor();
	constructor(x1: double, y1: double, width1: double, height1: double);
	/**
 *
 * @param stroke named color or hex color
 * @param strokeWidth width of line in # of pixels
 * @param fill named color or hex color
 * @returns
 */
	toSVGElement(stroke: string | null, strokeWidth: number, fill: string | null): string;
}
/**
 *
 *
 */
export declare class Font {
	static readonly PLAIN: number;
	static readonly BOLD: number;
	static readonly ITALIC: number;
	protected _size: number;
	protected _text: string;
	protected _type: number;
	constructor(s: string, type: number, size: number);
	getSize(): number;
	getName(): string;
	getType(): number;
	isBold(): boolean;
	getTypeString(): string;
	static getTypeString(type: number): string;
	static getTypeInt(type: string): number;
	toString(): string;
}
/**
 * Integer based Color class with utility functions
 */
export declare class Color {
	/**
	 * The color white.  In the default sRGB space.
	 */
	static readonly white: Color;
	/**
	 * The color white.  In the default sRGB space.
	 *
	 */
	static readonly WHITE: Color;
	/**
	 * The color light gray.  In the default sRGB space.
	 */
	static readonly lightGray: Color;
	/**
	 * The color light gray.  In the default sRGB space.
	 *
	 */
	static readonly LIGHT_GRAY: Color;
	/**
	 * The color gray.  In the default sRGB space.
	 */
	static readonly gray: Color;
	/**
	 * The color gray.  In the default sRGB space.
	 *
	 */
	static readonly GRAY: Color;
	/**
	 * The color dark gray.  In the default sRGB space.
	 */
	static readonly darkGray: Color;
	/**
	 * The color dark gray.  In the default sRGB space.
	 *
	 */
	static readonly DARK_GRAY: Color;
	/**
	 * The color black.  In the default sRGB space.
	 */
	static readonly black: Color;
	/**
	 * The color black.  In the default sRGB space.
	 *
	 */
	static readonly BLACK: Color;
	/**
	 * The color red.  In the default sRGB space.
	 */
	static readonly red: Color;
	/**
	 * The color red.  In the default sRGB space.
	 *
	 */
	static readonly RED: Color;
	/**
	 * The color pink.  In the default sRGB space.
	 */
	static readonly pink: Color;
	/**
	 * The color pink.  In the default sRGB space.
	 *
	 */
	static readonly PINK: Color;
	/**
	 * The color orange.  In the default sRGB space.
	 */
	static readonly orange: Color;
	/**
	 * The color orange.  In the default sRGB space.
	 *
	 */
	static readonly ORANGE: Color;
	/**
	 * The color yellow.  In the default sRGB space.
	 */
	static readonly yellow: Color;
	/**
	 * The color yellow.  In the default sRGB space.
	 *
	 */
	static readonly YELLOW: Color;
	/**
	 * The color green.  In the default sRGB space.
	 */
	static readonly green: Color;
	/**
	 * The color green.  In the default sRGB space.
	 *
	 */
	static readonly GREEN: Color;
	/**
	 * The color magenta.  In the default sRGB space.
	 */
	static readonly magenta: Color;
	/**
	 * The color magenta.  In the default sRGB space.
	 *
	 */
	static readonly MAGENTA: Color;
	/**
	 * The color cyan.  In the default sRGB space.
	 */
	static readonly cyan: Color;
	/**
	 * The color cyan.  In the default sRGB space.
	 *
	 */
	static readonly CYAN: Color;
	/**
	 * The color blue.  In the default sRGB space.
	 */
	static readonly blue: Color;
	/**
	 * The color blue.  In the default sRGB space.
	 *
	 */
	static readonly BLUE: Color;
	private _A;
	private _R;
	private _G;
	private _B;
	/**
 *
 * @param hexValue - String representing hex value (formatted "0xRRGGBB"
 * i.e. "0xFFFFFF") OR formatted "0xAARRGGBB" i.e. "0x00FFFFFF" for a color
 * with an alpha value I will also put up with "RRGGBB" and "AARRGGBB"
 * without the starting "0x" or "#"
 * @return
 */
	private getColorsFromHexString;
	constructor();
	constructor(color: Color);
	constructor(color: number);
	constructor(hexString: string);
	constructor(R: number, G: number, B: number);
	constructor(R: number, G: number, B: number, A: number);
	static makeColor(r: number, g: number, b: number): Color;
	toRGB(): number;
	toARGB(): number;
	private convert;
	/**
	 * A hex string in the format of AARRGGBB
	 * @param {Boolean} withAlpha Optional, default is true. If set to false,
	 * will return a hex string without alpha values.
	 */
	toHexString(withAlpha?: boolean): string;
	toString(): string;
	getRed(): number;
	getGreen(): number;
	getBlue(): number;
	getAlpha(): number;
	/**
	 *
	 * @param alpha 0-255
	 */
	setAlpha(alpha: number): void;
	toInt(): number;
	/**
	 * get alpha value from uint
	 * */
	private getAlphaFromColor;
	/**
	 * get red value from uint
	 * */
	private getRedFromColor;
	/**
	 * get green value from uint
	 * */
	private getGreenFromColor;
	/**
	 * get blue value from uint
	 * */
	private getBlueFromColor;
}
/**
 * Port of java.util.logging.Level class
 */
export declare class LogLevel {
	/**
	 * OFF is a special level that can be used to turn off logging.
	 * This level is initialized to <CODE>Integer.MAX_VALUE</CODE>.
	 */
	static OFF: LogLevel;
	/**
	 * SEVERE is a message level indicating a serious failure.
	 * <p>
	 * In general SEVERE messages should describe events that are
	 * of considerable importance and which will prevent normal
	 * program execution.   They should be reasonably intelligible
	 * to end users and to system administrators.
	 * This level is initialized to <CODE>1000</CODE>.
	 */
	static SEVERE: LogLevel;
	/**
	 * WARNING is a message level indicating a potential problem.
	 * <p>
	 * In general WARNING messages should describe events that will
	 * be of interest to end users or system managers, or which
	 * indicate potential problems.
	 * This level is initialized to <CODE>900</CODE>.
	 */
	static WARNING: LogLevel;
	/**
	 * INFO is a message level for informational messages.
	 * <p>
	 * Typically INFO messages will be written to the console
	 * or its equivalent.  So the INFO level should only be
	 * used for reasonably significant messages that will
	 * make sense to end users and system administrators.
	 * This level is initialized to <CODE>800</CODE>.
	 */
	static INFO: LogLevel;
	/**
	 * CONFIG is a message level for static configuration messages.
	 * <p>
	 * CONFIG messages are intended to provide a variety of static
	 * configuration information, to assist in debugging problems
	 * that may be associated with particular configurations.
	 * For example, CONFIG message might include the CPU type,
	 * the graphics depth, the GUI look-and-feel, etc.
	 * This level is initialized to <CODE>700</CODE>.
	 */
	static CONFIG: LogLevel;
	/**
	 * FINE is a message level providing tracing information.
	 * <p>
	 * All of FINE, FINER, and FINEST are intended for relatively
	 * detailed tracing.  The exact meaning of the three levels will
	 * vary between subsystems, but in general, FINEST should be used
	 * for the most voluminous detailed output, FINER for somewhat
	 * less detailed output, and FINE for the  lowest volume (and
	 * most important) messages.
	 * <p>
	 * In general the FINE level should be used for information
	 * that will be broadly interesting to developers who do not have
	 * a specialized interest in the specific subsystem.
	 * <p>
	 * FINE messages might include things like minor (recoverable)
	 * failures.  Issues indicating potential performance problems
	 * are also worth logging as FINE.
	 * This level is initialized to <CODE>500</CODE>.
	 */
	static FINE: LogLevel;
	/**
	 * FINER indicates a fairly detailed tracing message.
	 * By default logging calls for entering, returning, or throwing
	 * an exception are traced at this level.
	 * This level is initialized to <CODE>400</CODE>.
	 */
	static FINER: LogLevel;
	/**
	 * FINEST indicates a highly detailed tracing message.
	 * This level is initialized to <CODE>300</CODE>.
	 */
	static FINEST: LogLevel;
	/**
	 * ALL indicates that all messages should be logged.
	 * This level is initialized to <CODE>Integer.MIN_VALUE</CODE>.
	 */
	static ALL: LogLevel;
	private name;
	private value;
	constructor(name: string, value: number);
	intValue(): number;
	getName(): string;
}
/**
 * Error Logging class for Renderer
 *
 */
export declare class ErrorLogger {
	static readonly LoggerName: string;
	private static _level;
	private static _LoggingEnabled;
	private static dateFormatOptions;
	/**
	 * True if logging is enabled
	 * @return {@link Boolean}
	 */
	static getLoggingStatus(): boolean;
	/**
	 * Takes a throwable and puts it's stacktrace into a string.
	 * @param error {@link Error}
	 * @return {@link String}
	 */
	static getStackTrace(error: Error): string;
	/**
	 * TRUE: Creates a file handler that will log message to a file.
	 * FALSE: logging just goes to console.
	 * @param enable {@link Boolean}
	 */
	static EnableLogging(enable: boolean): void;
	/**
	 * Folder location to store the log file.
	 * Defaults to "System.getProperty("user.dir")"
	 * @param path {@link String}
	 * @deprecated
	 */
	static setLoggingPath(path: string): void;
	/**
	 * clears log files that are beyond a passed number of days old
	 * @param DaysOld {@link Integer}
	 * @deprecated
	 */
	static CleanupOldFiles(DaysOld: number): void;
	/**
	 * Set minimum level at which an item can be logged.
	 * In descending order:
	 * Severe
	 * Warning
	 * Info
	 * Config
	 * Fine
	 * Finer
	 * Finest
	 * @param newLevel {@link Level}
	 */
	static setLevel(newLevel: LogLevel): void;
	/**
	 * Set minimum level at which an item can be logged.
	 * In descending order:
	 * Severe
	 * Warning
	 * Info
	 * Config
	 * Fine
	 * Finer
	 * Finest
	 * @param newLevel {@link Level}
	 * @param setConsoleHandler logger could be set to FINE but the console
	 * handler could be set to INFO.  In that case, anything logged at FINE
	 * wouldn't show because it'd get blocked by the console handler.  Set to
	 * "true" to make sure the console handler will let you log at the level
	 * you want.  If you're only concerned with the log file, you can leave
	 * "false"
	 */
	static setLevel(newLevel: LogLevel, setConsoleHandler: boolean): void;
	/**
	 * Specify whether or not this logger should send its output
	 * to it's parent Logger.  This means that any LogRecords will
	 * also be written to the parent's Handlers, and potentially
	 * to its parent, recursively up the namespace.
	 * Defaults to true;
	 *
	 * @param useParentHandlers   true if output is to be sent to the
	 *		logger's parent.
	 */
	static setUseParentHandlers(useParentHandlers: boolean): void;
	/**
	 * Gets the java.util.logging.Level that the logger is set to.
	 * @return {@link Level}
	 */
	static getLevel(): LogLevel;
	/**
	 *
	 * @return {@link String}
	 * @deprecated
	 */
	private static getFileName;
	/**
	 * Log a method entry.
	 * <p>
	 * This is a convenience method that can be used to log entry
	 * to a method.  A LogRecord with message "ENTRY", log level
	 * FINER, and the given sourceMethod and sourceClass is logged.
	 * <p>
	 * @param   sourceClass    name of class that issued the logging request
	 * @param   sourceMethod   name of method that is being entered
	 */
	static Entering(sourceClass: string, sourceMethod: string): void;
	/**
	 * Log a method entry, with one parameter.
	 * <p>
	 * This is a convenience method that can be used to log entry
	 * to a method.  A LogRecord with message "ENTRY {0}", log level
	 * FINER, and the given sourceMethod, sourceClass, and parameter
	 * is logged.
	 * <p>
	 * @param   sourceClass    name of class that issued the logging request
	 * @param   sourceMethod   name of method that is being entered
	 * @param   param1	       parameter to the method being entered
	 */
	static Entering(sourceClass: string, sourceMethod: string, param1: any): void;
	/**
	 * Log a method entry, with an array of parameters.
	 * <p>
	 * This is a convenience method that can be used to log entry
	 * to a method.  A LogRecord with message "ENTRY" (followed by a
	 * format {N} indicator for each entry in the parameter array),
	 * log level FINER, and the given sourceMethod, sourceClass, and
	 * parameters is logged.
	 * <p>
	 * @param   sourceClass    name of class that issued the logging request
	 * @param   sourceMethod   name of method that is being entered
	 * @param   params	       array of parameters to the method being entered
	 */
	static Entering(sourceClass: string, sourceMethod: string, params: any[]): void;
	/**
	 * Log a method return.
	 * <p>
	 * This is a convenience method that can be used to log returning
	 * from a method.  A LogRecord with message "RETURN", log level
	 * FINER, and the given sourceMethod and sourceClass is logged.
	 * <p>
	 * @param   sourceClass    name of class that issued the logging request
	 * @param   sourceMethod   name of the method
	 */
	static Exiting(sourceClass: string, sourceMethod: string): void;
	/**
	 * Log a method return, with result object.
	 * <p>
	 * This is a convenience method that can be used to log returning
	 * from a method.  A LogRecord with message "RETURN {0}", log level
	 * FINER, and the gives sourceMethod, sourceClass, and result
	 * object is logged.
	 * <p>
	 * @param   sourceClass    name of class that issued the logging request
	 * @param   sourceMethod   name of the method
	 * @param   result  Object that is being returned
	 */
	static Exiting(sourceClass: string, sourceMethod: string, result: any): void;
	/**
	 * Defaults to Level.INFO
	 * @param message {@link String}
	 */
	static LogMessage(message: string): void;
	/**
	 * Defaults to Level.INFO
	 * @param message {@link String}
	 * @param showMessageBox (@link {@link Boolean}
	 */
	static LogMessage(message: string, showMessageBox: boolean): void;
	/**
	 *
	 * @param message {@link String}
	 * @param lvl {@link Level}
	 * @param showMessageBox {@link Boolean}
	 */
	static LogMessage(message: string, lvl: LogLevel, showMessageBox: boolean): void;
	static LogMessage(sourceClass: string, sourceMethod: string, message: string): void;
	static LogMessage(sourceClass: string, sourceMethod: string, message: string, showMessageBox: boolean): void;
	static LogMessage(sourceClass: string, sourceMethod: string, message: string, lvl: LogLevel): void;
	static LogMessage(sourceClass: string, sourceMethod: string, message: string, lvl: LogLevel, showMessageBox: boolean): void;
	static LogMessage(sourceClass: string, sourceMethod: string, message: string, lvl: LogLevel, param1: any, showMessageBox: boolean): void;
	static LogMessage(sourceClass: string, sourceMethod: string, message: string, lvl: LogLevel, params: any[], showMessageBox: boolean): void;
	static LogException(sourceClass: string, sourceMethod: string, exc: Error): void;
	static LogException(sourceClass: string, sourceMethod: string, exc: Error, showMessageBox: boolean): void;
	static LogException(sourceClass: string, sourceMethod: string, exc: Error, lvl: LogLevel): void;
	static LogException(sourceClass: string, sourceMethod: string, exc: Error, lvl: LogLevel, showMessageBox: boolean): void;
	static PrintList(list: Array<any>): string;
	static PrintObjectMap(map: Map<string, any>): string;
	static PrintStringMap(map: Map<string, string>): string;
}
/**
 * Symbol attribute constants
 */
export declare class MilStdAttributes {
	/**
	 * Line color of the symbol. hex value.
	 */
	static readonly LineColor: string;
	/**
	 * Fill color of the symbol. hex value
	 */
	static readonly FillColor: string;
	/**
	 * Main color of internal icon.  Only relevant to framed symbols. hex value
	 */
	static readonly IconColor: string;
	/**
	 * size of the single point image
	 */
	static readonly PixelSize: string;
	/**
	 * defaults to true
	 */
	static readonly KeepUnitRatio: string;
	/**
	 * transparency value of the symbol with values from 0 - 255.
	 */
	static readonly Alpha: string;
	/**
	 * outline the symbol, true/false
	 */
	static readonly OutlineSymbol: string;
	/**
	 * specify and outline color rather than letting renderer picking
	 * the best contrast color. hex value
	 */
	static readonly OutlineColor: string;
	/**
	 * just draws the core symbol
	 */
	static readonly DrawAsIcon: string;
	/**
	 * Specifies the line width of the multipoint symbology
	 */
	static readonly LineWidth: string;
	/**
	 * Specifies the color for text labels
	 */
	static readonly TextColor: string;
	/**
	 * Specifies the color for the text background (color outline or fill)
	 */
	static readonly TextBackgroundColor: string;
	/**
	 * If false, the renderer will create a bunch of little lines to create
	 * the "dash" effect (expensive but necessary for KML).
	 * If true, it will be on the user to create the dash effect using the
	 * DashArray from the Stroke object from the ShapeInfo object.
	 */
	static readonly UseDashArray: string;
	/**
	 * The mode that altitude labels will be displayed in, the default value is AMSL.
	 *
	 * This value acts as a label, appending whatever string that is passed in to the end of the altitude units.
	 * Currently only effective for multi-point graphics.
	 */
	static readonly AltitudeMode: string;
	/**
	 * At the moment, this refers to the optional range fan labels.
	 */
	static readonly HideOptionalLabels: string;
	/**
	 * For internal use
	 */
	static readonly UsePatternFill: string;
	/**
	 * For internal use
	 */
	static readonly PatternFillType: string;
	/**
	 * The conversion factor and the label that you want all distances to display in. The conversion factor
	 * is converting from meters. The default unit is meters.<br><br>
	 *
	 * Must be in the form [conversionFactor],[label]. So for example converting to feet would be "3.28084,FT".
	 * The helper class {@link DistanceUnit} can be used.
	 */
	static readonly DistanceUnits: string;
	/**
	 * The conversion factor and the label that you want all distances to display in.
	 * Conventionally, the conversion factor is converting from meters by default,
	 * but other values could be passed, like "1,KM" to use an unaltered value in kilometers.<br><br>
	 *
	 * Must be in the form [conversionFactor],[label]. So for example converting meters to feet would be "3.28084,FT".
	 * The helper class {@link DistanceUnit} can be used.
	 * Currently only effective for multi-point graphics.
	 */
	static readonly AltitudeUnits: string;
	/**
	 * If the engagement/target amplifier bar is to be used to designate targets, non-targets, and
	 * pruned or expired targets, a different coloring schema shall be used. Hostile tracks which
	 * are deemed targets shall have a red bar (RGB: 255, 0, 0) to indicate target. For hostile
	 * tracks deemed to be non-targets, white (RGB: 255, 255, 255) should be used to indicate non
	 * target. Finally, for hostile tracks which have been pruned or have expired shall be colored
	 * orange (RGB: 255, 120, 0).
	 * This attribute expects a hex string for the color
	 */
	static readonly EngagementBarColor: string;
	/**
	 * No Longer relevant
	 * @return
	 * @deprecated see {@link GetAttributesList()}
	 */
	static GetModifierList(): Array<string>;
	static GetAttributesList(symbolID: string): Array<string>;
	/**
	 * @param attribute constant like MilStdAttributes.LineColor
	 * @return attribute name based on attribute constants
	 */
	static getAttributeName(attribute: string): string;
	/**
	 * Takes a string representation of an attribute and returns the appropriate int key value
	 * @param attribute "LINECOLOR" will return MilStdAtttributes.LineColor
	 * @return number value representing Attribute constant.
	 */
	static getAttributeKey(attribute: string): string | null;
}
/**
 * Modifier Constants to be used as keys in the modifiers map
 */
export declare class Modifiers {
	/**
	 * <pre>
	 * Symbol Icon
	 * The innermost part of a symbol, comprised of an icon and optional modifiers, that represents a joint military object (see 5.3.4).
	 * Format: Graphic
	 * Symbol Set: All
	 * Remarks: Determined by SIDC positions 11-20.
	 * </pre>
	 */
	static readonly A_SYMBOL_ICON: string;
	/**
	 * <pre>
	 * Echelon
	 * An amplifier in a unit symbol that identifies command level (see 5.3.7.1 and table VII).
	 * Format: Graphic
	 * Symbol Set: All
	 * Remarks: Determined by SIDC positions 9-10.
	 * </pre>
	 */
	static readonly B_ECHELON: string;
	/**
	 * <pre>
	 * Quantity
	 * An amplifier in an equipment symbol that identifies the number of items present.
	 * Examples include:
	 * 350 Beds 50 Gallons
	 * Format:
	 * Alphanumeric - {1,19}
	 * [#########] [XXXXXXXXXX]
	 * Symbol Set: 10, 11, 15, 25, 27, 60
	 * Remarks: Two-part composite field.
	 * Where # is the numeric value [1-999999999], and X is the unit of measure.
	 * Note: There should be a space between the numeric and the unit of measure values.
	 * </pre>
	 */
	static readonly C_QUANTITY: string;
	/**
	 * <pre>
	 * Task Force Indicator
	 * An amplifier that identifies a unit or activities symbol as a task force (see 5.3.7.2 and figure 14).
	 * Format: Graphic
	 * Symbol Set: 10
	 * Remarks: Determined by SIDC position 8.
	 * </pre>
	 */
	static readonly D_TASK_FORCE_INDICATOR: string;
	/**
	 * <pre>
	 * Frame Shape Modifier
	 * A graphic modifier that displays standard identity, battle dimension, or exercise
	 * amplifying descriptors of an object (see 5.3.1 and table II).
	 * Format: Graphic
	 * Symbol Set: ALL BUT 25,45,46,47
	 * Remarks: 2525C, not processed as a modifier in 2525D+
	 * </pre>
	 */
	static readonly E_FRAME_SHAPE_MODIFIER: string;
	/**
	 * <pre>
	 * Reinforced or Reduced
	 * An amplifier in a unit symbol that displays (+) for reinforced, (-) for reduced, (<u>+</u>) reinforced and reduced.
	 * Format: Alphanumeric - {1,1}
	 * Symbol Set: 10
	 * Remarks:
	 * </pre>
	 */
	static readonly F_REINFORCED_REDUCED: string;
	/**
	 * <pre>
	 * Staff Comments
	 * An amplifier for units, equipment and installations; content is implementation specific.
	 * Format: Alphanumeric - {1,20}
	 * Symbol Set: 01, 05, 10, 15, 20, 27, 30, 35, 40
	 * Remarks:
	 * </pre>
	 */
	static readonly G_STAFF_COMMENTS: string;
	/**
	 * <pre>
	 * Additional Information
	 * An amplifier for units, equipment and installations; content is implementation specific.
	 * Format: Alphanumeric - {1,20}
	 * Symbol Set: ALL
	 * Remarks:
	 * </pre>
	 */
	static readonly H_ADDITIONAL_INFO_1: string;
	/**
	 * <pre>
	 * Unlisted Point Information
	 * An alphanumeric text amplifier used to provide an up to a three-character letter field acronym to describe a point that is not already listed.
	 * Format: Alphanumeric - {1,3}
	 * Symbol Set: 25
	 * Remarks: Only used with Action Points (General) control measure. SIDC 130100.
	 * </pre>
	 */
	static readonly H1_ADDITIONAL_INFO_2: string;
	/**
	 * A text modifier for tactical graphics; content is
	 * implementation specific.
	 * CM: P,L,A,N,B/C,R/N
	 * Length: 20
	 * @deprecated 2525C
	 */
	static readonly H2_ADDITIONAL_INFO_3: string;
	/**
	 * <pre>
	 * Evaluation Rating
	 * An amplifier that consists of a one-letter reliability rating and a one-number credibility rating. (See ATP 2-33.4)
	 * Format: Alphanumeric - {2,2} [X][#]
	 * Symbol Set: 10, 15, 20,27, 40
	 * Remarks:
	 *
	 * Reliability Ratings:
	 * A-completely reliable
	 * B-usually reliable
	 * C-fairly reliable
	 * D-not usually reliable
	 * E-unreliable
	 * F-reliability cannot be judged
	 *
	 * Credibility Ratings:
	 * 1-confirmed by other sources
	 * 2-probably true
	 * 3-possibly true
	 * 4-doubtfully true
	 * 5-improbable
	 * 6-truth cannot be judged
	 * </pre>
	 */
	static readonly J_EVALUATION_RATING: string;
	/**
	 * <pre>
	 * Effectiveness
	 * An amplifier for units and installations that indicates unit effectiveness or installation capability.
	 * Format: Alphanumeric - {2,3}
	 * Symbol Set: 10, 15, 27
	 * Remarks:
	 * List of Values:
	 * FO - Fully Operational
	 * SO - Substantially operational
	 * MO - Marginally operational
	 * NO - Not operational
	 * UNK - Unknown
	 * </pre>
	 */
	static readonly K_COMBAT_EFFECTIVENESS: string;
	/**
	 * <pre>
	 * Signature Equipment
	 * An amplifier for hostile equipment; "!" indicates detectable electronic signatures.
	 * Format: Alphanumeric - {1,1}
	 * Symbol Set: 15
	 * Remarks: The amplifier displayed is the exclamation mark "!".
	 * </pre>
	 */
	static readonly L_SIGNATURE_EQUIP: string;
	/**
	 * <pre>
	 * Higher Formation
	 * An amplifier for units that indicates number or title of higher echelon command (corps are designated by Roman numerals).
	 * Format: Alphanumeric - {1,21}
	 * Symbol Set: 10
	 * Remarks: The amplifier displayed is the exclamation mark "!".
	 * </pre>
	 */
	static readonly M_HIGHER_FORMATION: string;
	/**
	 * <pre>
	 * Hostile (Enemy)
	 * An amplifier for equipment; letters "ENY" denote hostile symbols.
	 * Format: Alphanumeric - {3,3}
	 * Symbol Set: 15,25
	 * Remarks: Determined by SIDC position 4.
	 * Note: This amplifier must be used when displaying enemy/hostile control measures on monochromatic displays
	 * </pre>
	 */
	static readonly N_HOSTILE: string;
	/**
	 * <pre>
	 * IFF/SIF/AIS
	 * An amplifier displaying IFF/SIF/AIS Identification modes and codes.
	 * Format:
	 * Symbol Set: 01, 10, 15, 27, 30, 35
	 * Remarks: 'MODE' is not required when displaying.
	 * </pre>
	 */
	static readonly P_IFF_SIF_AIS: string;
	/**
	 * <pre>
	 * Direction of Movement Indicator
	 * An amplifier consisting of a line with arrow that identifies the direction of movement or intended movement of an object (see 5.3.7.9 and figure 14).
	 * Format: Graphic (Alphanumeric for exchange only)
	 * Symbol Set: 10, 15, 20, 25, 27
	 * Remarks:
	 * Renderer Assumes a value in degrees with no text
	 * MilStd:
	 *
	 * </pre>
	 */
	static readonly Q_DIRECTION_OF_MOVEMENT: string;
	/**
	 * <pre>
	 * Mobility Indicator
	 * An amplifier that depicts the mobility of an object not intrinsic to the entity itself (see 5.3.7.9, figure 14 and table IX).
	 * Format: Graphic
	 * Symbol Set: 10
	 * Remarks: Determined by SIDC positions 9-10
	 * </pre>
	 */
	static readonly R_MOBILITY_INDICATOR: string;
	/**
	 * <pre>
	 * SIGINT Mobility Indicator
	 * An amplifier that indicates the mobility of a SIGINT unit.
	 * Format: Alphanumeric - {1,1}
	 * Symbol Set: 50, 51, 52, 53, 54
	 * Remarks:
	 * List of Values:
	 * M = Mobile,
	 * S = Static
	 * U = Uncertain.
	 * </pre>
	 */
	static readonly R2_SIGNIT_MOBILITY_INDICATOR: string;
	/**
	 * <pre>
	 * Headquarters Staff Indicator
	 * An amplifier for units, installations and activities that identifies them as a headquarters (see figure 14 and figure 13).
	 * Format: Graphic
	 * Symbol Set: 10, 20, 40
	 * Remarks: Determined by SIDC position 8.
	 * </pre>
	 */
	static readonly S_HQ_STAFF_INDICATOR: string;
	/**
	 * <pre>
	 * Offset Location Indicator
	 * An amplifier used to indicate the offset or precise location of a single point symbol (see 5.3.7.5, 5.3.12, and figure 14).
	 * Format: Graphic
	 * Symbol Set: 10, 20, 25, 27, 40
	 * Remarks: Determined by individual system implementations, not implemented by the renderer.
	 * </pre>
	 */
	static readonly S2_OFFSET_INDICATOR: string;
	/**
	 * <pre>
	 * Unique Designation
	 * An amplifier that uniquely identifies a particular symbol or track number. Identifies acquisitions number when used with SIGINT symbology.
	 * Format: Alphanumeric - {1,30}
	 * Symbol Set: All
	 * Remarks:
	 * </pre>
	 */
	static readonly T_UNIQUE_DESIGNATION_1: string;
	/**
	 * <pre>
	 * Lines - Unique Identifier or Primary Purpose
	 * An amplifier that uniquely identifies a particular symbol or track number. Identifies acquisitions number when used with SIGINT symbology.
	 * Format: Alphanumeric - {1,30}
	 * Symbol Set: All
	 * Remarks:
	 * </pre>
	 */
	static readonly T1_UNIQUE_DESIGNATION_2: string;
	/**
	 * <pre>
	 * Type
	 * An amplifier for equipment that indicates types of equipment.
	 * Format: Alphanumeric - {1,24}
	 * Symbol Set: Not Installation(20), Activites(40), or CyberSpace(60)
	 * Remarks:
	 * Example:
	 * AH-64 for Attack Helicopter
	 * </pre>
	 */
	static readonly V_EQUIP_TYPE: string;
	/**
	 * <pre>
	 * Date/Time Group (DTG) W
	 * An amplifier for displaying a date-time group (DDHHMMSSZMONYYYY) or (DDHHMMZMMMYYYY) or "O/O" for On Order.
	 * Field "W" is used to provide DTG or if used with field "W1" the start of a period of time.
	 * Field "W1" is used to provide the end of a period of time.
	 * Format: Alphanumeric - {3,16}
	 * Symbol Set: 10, 15, 20, 25, 27, 40, 45
	 * Remarks:
	 * The date-time group is composed of a group of six numeric digits with a time zone suffix and the standardized three-letter abbreviation for the month followed by four digits representing the year.
	 * The first pair of digits represents the day; the second pair, the hour; the third pair, the minutes. For automated systems, two digits may be added before the time zone suffix and after the minutes to designate seconds (see 5.3.7.8).
	 * </pre>
	 */
	static readonly W_DTG_1: string;
	/**
	 * <pre>
	 * Date/Time Group (DTG) W1
	 * An amplifier for displaying a date-time group (DDHHMMSSZMONYYYY) or (DDHHMMZMMMYYYY) or "O/O" for On Order.
	 * Field "W" is used to provide DTG or if used with field "W1" the start of a period of time.
	 * Field "W1" is used to provide the end of a period of time.
	 * Format: Alphanumeric - {3,16}
	 * Symbol Set: 25
	 * Remarks:
	 * The date-time group is composed of a group of six numeric digits with a time zone suffix and the standardized three-letter abbreviation for the month followed by four digits representing the year.
	 * The first pair of digits represents the day; the second pair, the hour; the third pair, the minutes. For automated systems, two digits may be added before the time zone suffix and after the minutes to designate seconds (see 5.3.7.8).
	 * </pre>
	 */
	static readonly W1_DTG_2: string;
	/**
	 * <pre>
	 * Altitude/Depth
	 * An amplifier that displays either altitude, flight level, depth for submerged objects or height of equipment or structures on the ground, the minimum, maximum and/or specific altitude (in feet or meters in relation to a reference datum) or depth (for submerged objects in feet below sea level). See 5.3.7.6 for content.
	 * Format:
	 * Symbol Set: All but 40 & 60
	 * Remarks:
	 * SM = Statute Miles
	 * DM = Data Miles
	 * Notes:
	 * The Renderer handles the whole value as a string for Single Point Icons.
	 * For multipoints, it expects just a number and an accompanying attribute {@link MilStdAttributes.AltitudeUnits}
	 * Default behavior assumes feet.
	 * </pre>
	 */
	static readonly X_ALTITUDE_DEPTH: string;
	/**
	 * <pre>
	 * Location
	 * An amplifier that displays a symbol's location in degrees, minutes and decimal minutes (or in MGRS, GARS, or other applicable display formats).
	 * Format: Alphanumeric - {3,16}
	 * Symbol Set: 10, 15, 20, 25, 27, 30, 40
	 * Remarks: Exchange format is implementation specific.
	 * </pre>
	 */
	static readonly Y_LOCATION: string;
	/**
	 * <pre>
	 * Speed
	 * An amplifier that displays velocity (see 5.3.7.7).
	 * Format: Alphanumeric - {5,9} [#####] [XXX]
	 * Symbol Set: NOT 20, 35, 40, 60
	 * Remarks:
	 * Two-part composite field.
	 * Where # is the numeric value [1-999999999], and XXX is the unit of measure (KPH, KPS, MPH, NMH, KTS).
	 * Note: There should be a space between the numeric and the unit of measure values.
	 * </pre>
	 */
	static readonly Z_SPEED: string;
	/**
	 * <pre>
	 * Special C2 Headquarters
	 * A amplifier that is contained inside the frame in place of the main icon and contains the name of the special C2 Headquarters.
	 * Format: Alphanumeric - {1,9}
	 * Symbol Set: 10
	 * Remarks:
	 * Examples: Named command such as SHAPE, PACOM, and joint, multinational, or coalition commands such as CJTF, JTF, or MJTF.
	 * </pre>
	 */
	static readonly AA_SPECIAL_C2_HQ: string;
	/**
	 * <pre>
	 * Feint/Dummy indicator
	 * An amplifier that identifies an offensive or defensive unit, intended to draw the enemy's attention away from the area of the main attack.
	 * Format: Graphic
	 * Symbol Set: 10, 15, 20, 25
	 * Remarks: Determined by SIDC position 8.
	 * </pre>
	 */
	static readonly AB_FEINT_DUMMY_INDICATOR: string;
	/**
	 * <pre>
	 * Platform Type
	 * An amplifier that identifies the electronic identification for a pulsed or non-pulsed electromagnetic emission.
	 * Format: Alphanumeric - {5,5}
	 * Symbol Set: 10, 15
	 * Remarks:
	 * List of Values:
	 * ELNOT = Electronic intelligence notation
	 * CENOT = Communications intelligence notation
	 * </pre>
	 */
	static readonly AD_PLATFORM_TYPE: string;
	/**
	 * <pre>
	 * Platform Type
	 * An amplifier that identifies equipment teardown time in minutes.
	 * Format: Numeric – {1,3}
	 * Symbol Set: 10(2525E), 15
	 * Remarks:
	 * </pre>
	 */
	static readonly AE_EQUIPMENT_TEARDOWN_TIME: string;
	/**
	 * <pre>
	 * Common Identifier
	 * An amplifier to provide a common name used to identify an entity.
	 * Format: Alphanumeric - {1,12}
	 * Symbol Set: 10(2525E), 15, 27
	 * Remarks: Example: "Hawk" for Hawk SAM system.
	 * </pre>
	 */
	static readonly AF_COMMON_IDENTIFIER: string;
	/**
	 * <pre>
	 * Auxiliary Equipment Indicator
	 * An amplifier for equipment that indicates the presence of a towed sonar array (see 5.3.7.11, figure 14 and table IX).
	 * Format: Graphic
	 * Symbol Set: 15
	 * Remarks: Determined by SIDC positions 9-10.
	 * </pre>
	 */
	static readonly AG_AUX_EQUIP_INDICATOR: string;
	/**
	 * <pre>
	 * Area of Uncertainty
	 * An amplifier that indicates the area where an object is most likely to be, based on the object's last report and
	 * the reporting accuracy of the sensor that detected the object (see 5.3.7.13.1 and figure 18.
	 * Format: Graphic (Alphanumeric for exchange only)
	 * Symbol Set: 01, 05, 10, 15, 20, 25, 27, 30, 35, 40
	 * Remarks:
	 * The amplifier can be displayed as an ellipse, a bearing box, or a line of bearing, depending on the report received for the object.
	 * Notes: Not implemented by the renderer
	 * </pre>
	 */
	static readonly AH_AREA_OF_UNCERTAINTY: string;
	/**
	 * <pre>
	 * Dead Reckoning Trailer
	 * An amplifier that identifies where an object should be located at present, given its last reported course and speed (see 5.3.7.13.2).
	 * Format: Graphic
	 * Symbol Set: 01, 05, 10, 15, 20, 25, 27, 30, 35, 40
	 * Remarks:
	 * Locally derived information. This datum is not exchanged.
	 * Notes: Not implemented by the renderer
	 * </pre>
	 */
	static readonly AI_DEAD_RECKONING_TRAILER: string;
	/**
	 * <pre>
	 * Speed Leader
	 * An amplifier that depicts the speed and direction of movement of an object (see 5.3.7.13.3 and figure 18).
	 * Format: Graphic
	 * Symbol Set: 10, 15, 30, 35
	 * Remarks:
	 * Land units and equipment use the Direction of Movement and Speed amplifiers for this information.
	 * Notes: Not implemented by the renderer
	 * </pre>
	 */
	static readonly AJ_SPEED_LEADER: string;
	/**
	 * <pre>
	 * Pairing Line
	 * An amplifier that connects two objects and is updated dynamically as the positions of the two objects change (see 5.3.7.13.4 and figure 18).
	 * Format: Graphic
	 * Symbol Set: NA
	 * Remarks:
	 * Notes: Not implemented by the renderer
	 * </pre>
	 */
	static readonly AK_PAIRING_LINE: string;
	/**
	 * <pre>
	 * Operational Condition
	 * An amplifier that indicates operational condition or capacity.
	 * Format: Graphic
	 * Symbol Set: 01, 05,10, 15, 20, 30, 35
	 * Remarks: Determined by SIDC position 7.
	 * </pre>
	 */
	static readonly AL_OPERATIONAL_CONDITION: string;
	/**
	 * <pre>
	 * Distance
	 * An amplifier that displays a minimum, maximum, or a specific distance (range, radius, width, length, etc.), in meters.
	 * Format: Alphanumeric - {3,9} [#] [X]
	 * Symbol Set: 25
	 * Remarks:
	 * "#" is the value (range 0-99999)
	 * XXX is the distance unit.
	 * There should be a space between the integer and the unit of measure values.
	 * Where more than one distance is specified the AM amplifier will be suffixed with a numeric entry, e.g. AM1, AM2.
	 * Note:
	 * Renderer expects just a number or a comma delimited string of numbers and an accompanying attribute {@link MilStdAttributes.DistanceUnits}
	 * Default behavior assumes meters.
	 * </pre>
	 */
	static readonly AM_DISTANCE: string;
	/**
	 * <pre>
	 * Azimuth
	 * An amplifier that displays an angle measured from true north to any other line in degrees.
	 * Format: Alphanumeric - {7,8} [#####] [XXX]
	 * Symbol Set: 25
	 * Remarks:
	 * For Degrees entries.
	 * XXX DGT, where XXX is degrees from 000-359 and DGT is referenced to TRUE North.
	 * For Mils entries.
	 * XXXX MGT, where XXXX is MILS from 0000-6399 and MGT is referenced to TRUE North.
	 * Where more than one angle is specified the AN amplifier will be suffixed with a numeric entry, e.g. AN1, AN2.
	 * Note:
	 * Renderer expects just a number or a comma delimited string of numbers
	 * </pre>
	 */
	static readonly AN_AZIMUTH: string;
	/**
	 * Engagement Bar
	 * A graphic amplifier placed immediately atop the symbol. May denote:
	 * A) local/remote engagement status - 'R' for remote, 'B' for mix of local/remote, none for local
	 * B) engagement status
	 * C) weapon type.
	 *
	 * Format:
	 * Composite list of values
	 * Alphanumeric - {6,10}
	 * A:BBB-CC
	 * Symbol Set: 01, 05, 10, 30, 35
	 * Remarks: See 5.3.7.15.3 for explanation of engagement bar structure and codes.
	 * A - Type of Engagement
	 * BBB - Engagement Stage
	 * CC - Type of Weapon Assignment
	 */
	static readonly AO_ENGAGEMENT_BAR: string;
	/**
	 * <pre>
	 * Target Number
	 * An amplifier used in Fire Support operations to uniquely designate targets in accordance with STANAG 2934.
	 * Format: Alphanumeric - {6,6} [XX][####]
	 * Symbol Set: 25
	 * Remarks:
	 * Two-part composite field.
	 * Where positions 1-2 are text, and positions 3-6 are numeric.
	 * </pre>
	 */
	static readonly AP_TARGET_NUMBER: string;
	/**
	 * <pre>
	 * Target Number Extension
	 * An amplifier used to identify a target number extension which is a sequentially assigned number identifying the individual elements in a target (MIL-STD-6017),
	 * Format: Numeric – {2,3} [-##]
	 * Symbol Set: 25
	 * Remarks:
	 * Position 1 is a dash (-) and positions 2-3 are numbers, from 1 through 15.
	 * It is applicable only to the "Point or Single Target" symbol.
	 * It is conditional upon the presence of the Target Number amplifier and is visually displayed appended to the Target Number amplifier.
	 * </pre>
	 */
	static readonly AP1_TARGET_NUMBER_EXTENSION: string;
	/**
	 * <pre>
	 * Guarded Unit
	 * An amplifier used during ballistic missile defense. Some tracks are designated as guarded by a particular unit.
	 * Format: Alphanumeric - {6,6} [XX]
	 * Symbol Set: 10(2525E), 15, 20(2525E), 30
	 * Remarks:
	 * Single value:
	 * BG - Guarded Unit
	 * </pre>
	 */
	static readonly AQ_GUARDED_UNIT: string;
	/**
	 * <pre>
	 * Special Designator
	 * An amplifier that identifies special track designators.
	 * Format: Alphanumeric - {3,3}
	 * Symbol Set: 10, 30, 35
	 * Remarks:
	 * List of values:
	 * NRT - Non-Real Time.
	 * SIG - Tactically Significant Tracks.
	 * </pre>
	 */
	static readonly AR_SPECIAL_DESIGNATOR: string;
	/**
	 * <pre>
	 * Country
	 * A three-letter code that indicates the country of origin of the organization (US systems shall use GENC).
	 * Format: Alphanumeric - {3,3}
	 * Symbol Set: All
	 * Remarks: Determined by SIDC positions 28-30.
	 * </pre>
	 */
	static readonly AS_COUNTRY: string;
	/**
	 * <pre>
	 * Capacity of Installation
	 * Capacity of installation displayed.
	 * Format: Alphanumeric - {1,19} [#########] [XXXXXXXXXX]
	 * Symbol Set: 2525E addition, not currently defined.  Probably 20
	 * Remarks:
	 * Two-part composite field.
	 * Comprised of:
	 * Quantity 0-99999999 followed by the unit of measure.
	 * e.g. 400 Beds
	 * </pre>
	 */
	static readonly AT_CAPACITY_OF_INSTALLATION: string;
	/**
	 * <pre>
	 * Leadership
	 * Identifies Leadership (ONLY IN DISMOUNTED INDIVIDUAL)
	 * Format: Graphic
	 * Symbol Set: 27(2525E)
	 * Remarks: Determined by SIDC positions 9-10.
	 * </pre>
	 */
	static readonly AV_LEADERSHIP: string;
	/**
	 * <pre>
	 * Headquarters Element
	 * An amplifier that indicates what type of element of a headquarters is being represented, such as TOC, MAIN2.
	 * Format: Alphanumeric {0,8}
	 * Symbol Set: 10(2525E)
	 * Remarks: Location currently undefined
	 * </pre>
	 */
	static readonly AW_HEADQUARTERS_ELEMENT: string;
	/**
	 * <pre>
	 * Installation Composition
	 * Indicates the component type of the installation
	 * Format: Alphanumeric {3,7}
	 * Symbol Set: 20(2525E)
	 * Remarks: Location currently undefined
	 * List of Values:
	 * DEVELOP - Development.
	 * RSRCH - Research.
	 * PROD - Production.
	 * SVC - Service.
	 * STORE - Storage.
	 * UTIL - Utility.
	 * </pre>
	 */
	static readonly AX_INSTALLATION_COMPOSITION: string;
	/**
	 * <pre>
	 * Network Identifier
	 * Indicates the network the entity has privileges within.
	 * Format: Alphanumeric
	 * Symbol Set: undefined
	 * Remarks:
	 * The colour of the graphic shall be assignable by the operator.
	 * Notes: undefined
	 * </pre>
	 */
	static readonly AY_NETWORK_IDENTIFIER: string;
	/**
	 * Returns an Arraylist of the all the modifiers that appear as labels and are not
	 * derived from the symbol code or are external to symbol data like offset indicator.
	 * Also includes modifiers that control the shape of a symbol like AM &amp; AN.
	 * @return Array<string>
	 */
	static GetModifierList(): Array<string>;
	/**
	 * Returns an ArrayList of the modifier constants that are determined by the symbol code
	 * and therefore don't need their values to be manually typed or selected.
	 * (Based on the comments in GetModifierList, GetUnitModifierList, and GetControlMeasureModifierList.)
	 * @return Array<string>
	 */
	static GetSymbolCodeModifiersList(): Array<string>;
	/**
	 * Returns an Arraylist of the modifier names for units
	 * @return Array<string>
	 */
	static GetUnitModifierList(): Array<string>;
	/**
	 * Returns an Arraylist of the modifiers for Control Measures
	 * @return Array<string>
	 */
	static GetControlMeasureModifierList(): Array<string>;
	/**
	 *
	 * @param modifier like Modifiers.C_QUANTITY
	 * @return modifier name based on modifier constants
	 */
	static getModifierName(modifier: string): string;
	/**
	 *
	 * @param modifier like Modifiers.C_QUANTITY
	 * @return modifier name based on modifier constants
	 */
	static getModifierLetterCode(modifier: string): string;
	/**
	 * Returns the description for a modifier constant
	 * @param modifier {@link Modifiers}
	 * @return
	 */
	static getModifierDescription(modifier: string): string;
	/**
	 * go from "T" or "T1" to integer constant values 9 and 10
	 * @param modLetter
	 * @return {@link Modifiers}
	 */
	static getModifierKey(modLetter: string): string | null;
}
/**
 * Draw Rules for Control Measures
 *
 */
export declare class DrawRules {
	/**
	 * Usually an entry in the MilStd that is just a category containing other symbols
	 * and not something that gets drawn itself.
	 */
	static readonly DONOTDRAW: number;
	/**
	 * Anchor Points: This symbol requires at least three anchor points to
	 * define the boundary of the area. Add as many points as necessary to
	 * accurately reflect the area’s size and shape.
	 *
	 * Size/Shape: Determined by the anchor points. The information fields
	 * should be moveable and scalable as a block within the area.
	 *
	 * Orientation: Not applicable.
	 */
	static readonly AREA1: number;
	/**
	 * Anchor Points: This symbol requires at least three anchor points to
	 * define the boundary of the area. Add as many points as necessary to
	 * accurately reflect the area’s size and shape. The LAA point symbol
	 * requires one anchor point and is connected to the area symbol with a
	 * straight line.
	 *
	 * Size/Shape: Determined by the anchor points. The information fields
	 * should be moveable and scalable as a block within the area.
	 *
	 * Orientation: Not applicable.
	 */
	static readonly AREA2: number;
	/**
	 * Anchor Points: This symbol requires at least three anchor points to
	 * define the boundary of the area. Add as many points as necessary to
	 * accurately reflect the area’s size and shape.
	 *
	 * Size/Shape: Determined by the anchor points.
	 *
	 * Orientation: The side opposite Field B (Echelon) faces toward the
	 * hostile force.
	 */
	static readonly AREA3: number;
	/**
	 * Anchor Points: This symbol requires at least three anchor points to
	 * define the boundary of the area. Add as many points as necessary to
	 * accurately reflect the area’s size and shape.
	 *
	 * Size/Shape: Determined by the anchor points. The information fields
	 * should be moveable and scalable as a block within the area. The default
	 * tic length should be the same as the text height of the echelon
	 * field (B). Spacing between the tics should also be the height of B.
	 * Users should be provided a facility to allow them to manually alter the
	 * height of B, which in turn should affect the tic length and spacing
	 * accordingly.
	 *
	 * Orientation: Not applicable.
	 */
	static readonly AREA4: number;
	/**
	 * Anchor Points: This symbol requires three anchor points. Points 1 and 2
	 * define the endpoints of the semicircle's opening. Point 3 defines the end
	 * of the arrow.
	 *
	 * Size/Shape: Points 1 and 2 determine the diameter of the semicircle and
	 * point 3 determines the length of the arrow. The tip of the arrowhead will
	 * be at the center point of the semicircle's diameter and will project
	 * perpendicularly from the line between points 1 and 2. The default tic
	 * length should be the same as the text height of the echelon field (B).
	 * Spacing between the tics should also be the height of B. Users should be
	 * provided a facility to allow them to manually alter the height of B,
	 * which in turn should affect the tic length and spacing accordingly.
	 *
	 * Orientation: The opening typically faces enemy forces.
	 */
	static readonly AREA5: number;
	/**
	 * Anchor Points: This symbol requires two anchor points. Point 1 defines
	 * the center point of the symbol and point 2 defines the symbol’s start
	 * point and radius.
	 *
	 * Size/Shape: Points 1 and 2 will determine a radius that is long enough
	 * for the graphic to encompass the feature(s) being retained. The opening
	 * will be a 30-degree arc of the circle. The default tic length should be
	 * the same as the text height of the echelon field (R). Spacing between
	 * the tics should also be the height of R. Users should be provided a
	 * facility to allow them to manually alter the height of R, which in turn
	 * should affect the tic length and spacing accordingly.
	 *
	 * Orientation: The opening will be on the friendly side of the symbol.
	 */
	static readonly AREA6: number;
	/**
	 * Anchor Points: This symbol requires three anchor points. Point 1 is the
	 * tip of the arrowhead. Points 2 and 3 define the endpoints of the straight
	 * line on the back side of the symbol.
	 *
	 * Size/Shape: Points 2 and 3 determine the length of the straight line on
	 * the back side of the symbol. The rear of the arrowhead line shall connect
	 * to the midpoint of the line between points 2 and 3. The arrowhead line shall be perpendicular to the line formed by points 2 and 3.
	 *
	 * Orientation: Orientation is determined by the anchor points. The back
	 * side of the symbol encompasses the firing position, while the arrowhead
	 * typically points at the target.
	 */
	static readonly AREA7: number;
	/**
	 * Anchor Points: This symbol requires four anchor points. Points 1 and 2
	 * define the endpoints of the straight line on the back side of the symbol.
	 * Points 3 and 4 define the tips of the arrowheads.
	 *
	 * Size/Shape: Points 1 and 2 determine the length of the straight line on
	 * the back side of the symbol. The rear of the arrows should connect to
	 * points 1 and 2.
	 *
	 * Orientation: Orientation is determined by the anchor points. The back
	 * side of the symbol encompasses the firing position, while the arrowheads
	 * typically indicate the left and right limits of coverage that the firing
	 * position is meant to support.
	 */
	static readonly AREA8: number;
	/**
	 * Anchor Points: This symbol requires at least three anchor points to
	 * define the boundary of the area. Add as many points as necessary to
	 * accurately reflect the area’s size and shape.
	 *
	 * Size/Shape: Determined by the anchor points.
	 *
	 * Orientation: Not applicable. The area will encompass two or more fire
	 * support symbols (point/single target, nuclear target, circular target,
	 * rectangular target, or area target).
	 * The naming convention determines whether the area describes a series or
	 * group of targets.
	 *
	 */
	static readonly AREA9: number;
	/**
	 * Anchor Points: This symbol requires a minimum of three (3) and a maximum
	 * of six (6) anchor points to define the boundary of the area. The anchor
	 * points shall be sequentially numbered, in increments of one (1),
	 * beginning with point one (1).
	 *
	 * Size/Shape: Determined by the anchor points. The information fields
	 * should be moveable and scalable within the area.
	 *
	 * Orientation: Not applicable.
	 */
	static readonly AREA10: number;
	/**
	 * Anchor Points: This symbol requires three anchor points. Points 1 and 2
	 * define the endpoints of the symbol’s vertical line. Point 3 defines the
	 * endpoint of the symbol’s horizontal line.
	 *
	 * Size/Shape: Points 1 and 2 determine the length of the vertical line.
	 * The length of the horizontal line is determined by plotting point 3 on a
	 * plane extending perpendicularly from the midpoint of the vertical line.
	 *
	 * Orientation: The head of the "T" typically faces enemy forces.
	 */
	static readonly AREA11: number;
	/**
	 * Anchor Points: This symbol requires three anchor points. Points 1 and 2
	 * define the end points of the symbol’s vertical line. Point 3 defines the
	 * tip of the longest arrow.
	 *
	 * Size/Shape: Points 1 and 2 determine the height of the symbol and point
	 * 3 determines its length. The spacing between the symbol’s arrows will
	 * stay proportional to the symbol’s vertical line. The length of the short
	 * arrows will remain in proportion to the length of the longest arrow.
	 *
	 * Orientation: The arrows point away from enemy forces.
	 */
	static readonly AREA12: number;
	/**
	 * Anchor Points: This symbol requires at least two anchor points. Points
	 * 1 and 2 define the corners of the symbol.
	 *
	 * Size/Shape: Points 1 and 2 determine the length of the straight line.
	 * The radius of the semicircle is ½ the length of the straight line.
	 *
	 * Orientation: Not applicable.
	 */
	static readonly AREA13: number;
	/**
	 * Anchor Points: This symbol requires three anchor points. The center point
	 * defines the center of the symbol. Points 1 and 2 define the radii of
	 * circles 1 and 2.
	 *
	 * Size/Shape: As defined by the operator.
	 *
	 * Orientation: The center point is typically centered over Ground Zero (GZ)
	 * or Designated Ground Zero (DGZ).
	 */
	static readonly AREA14: number;
	/**
	 * Anchor Points: This symbol requires two anchor points. Point 1 defines
	 * the center point of the symbol and point 2 defines the symbol’s start
	 * point and radius.
	 *
	 * Size/Shape: The radius will be long enough for the symbol to encompass
	 * the UEI(s) or feature(s) being isolated. The opening will be a 30 degree
	 * arc of the circle.
	 *
	 * Orientation: The opening will be on the friendly side of the symbol.
	 */
	static readonly AREA15: number;
	/**
	 * Anchor Points: This symbol requires two anchor points. Point 1 defines
	 * the center point of the symbol and point 2 defines the symbol’s start
	 * point and radius.
	 *
	 * Size/Shape: Points 1 and 2 will determine a radius that is long enough
	 * for the symbol to encompass the feature(s) being occupied. The opening
	 * will be a 30-degree arc of the circle.
	 *
	 * Orientation: The opening will be on the friendly side of the
	 * control measure.
	 */
	static readonly AREA16: number;
	/**
	 * Anchor Points: This symbol requires three anchor points. Points 1 and 2
	 * define the endpoints of the symbol’s vertical line. Point 3 defines the
	 * rear of the symbol.
	 *
	 * Size/Shape: Points 1 and 2 determine the height of the symbol and
	 * point 3 determines its length. The arrow will project perpendicularly
	 * from the midpoint of the vertical line.
	 *
	 * Orientation: The arrow points toward enemy forces.
	 */
	static readonly AREA17: number;
	/**
	 * Anchor Points: This symbol requires four anchor points. Point 1 defines
	 * the tip of the first arrowhead. Point 2 defines the end of the straight
	 * line portion of the first arrow. Point 3 defines the tip of the second
	 * arrowhead. Point 4 defines the end of the second arrow.
	 *
	 * Size/Shape: Points 1 and 2 and points 3 and 4 determine the length of
	 * each arrow. Points 2 and 3 shall be connected by a smooth, curved line.
	 *
	 * Orientation: Determined by the anchor points. The unit being relieved is
	 * typically located at the base of the curve and the unit performing the
	 * relief is typically located at the end of the symbol. The arrowhead
	 * typically points to the location the relieved unit should move to.
	 */
	static readonly AREA18: number;
	/**
	 * Anchor Points: This symbol requires two anchor points. Point 1 defines
	 * the center point of the symbol and point 2 defines the symbol’s start
	 * point and radius.
	 *
	 * Size/Shape: Points 1 and 2 will determine a radius that is long enough
	 * for the symbol to encompass the feature(s) being secured. The opening
	 * will be a 30-degree arc of the circle.
	 *
	 * Orientation: The opening will be on the friendly side of the symbol.
	 */
	static readonly AREA19: number;
	/**
	 * Anchor Points: This symbol requires at least three anchor points to
	 * define the boundary of the area. Add as many points as necessary to
	 * accurately reflect the area’s size and shape.
	 *
	 * Size/Shape: Determined by the anchor points.
	 *
	 * Orientation: Not applicable.
	 */
	static readonly AREA20: number;
	/**
	 * Anchor Points: This symbol requires three anchor points. Point 1 defines
	 * the vertex of the symbol. Points 2 and 3 define the tips of the
	 * arrowheads.
	 *
	 * Size/Shape: Points 1 and 2 and points 1 and 3 determine the length of the
	 * arrows. The length and orientation of the arrows can vary independently.
	 *
	 * Orientation: Orientation is determined by the anchor points.
	 * The arrowheads may touch other symbols that define the limits of the
	 * task. The tactical symbol indicator is centered over point 1.
	 */
	static readonly AREA21: number;
	/**
	 * Anchor Points: This symbol requires one anchor point. The center point
	 * defines the center of the symbol.
	 *
	 * Size/Shape: Static.
	 *
	 * Orientation: The symbol is typically centered over the desired location.
	 */
	static readonly AREA22: number;
	/**
	 * Anchor Points: This symbol requires at least three anchor points to
	 * define the boundary of the area.
	 *
	 * Size/Shape: Determined by the anchor points
	 *
	 * Orientation: Not applicable.
	 */
	static readonly AREA23: number;
	/**
	 * Anchor Points: This symbol requires three anchor points. Points 1 and 2
	 * define the endpoints of the symbol’s vertical line. Point 3 defines the
	 * endpoint of the symbol’s horizontal line.
	 *
	 * Size/Shape: Points 1 and 2 determine the length of the vertical line.
	 * Points 2 and 3 determine the length of the horizontal line, which will
	 * project perpendicularly from the midpoint of the vertical line.
	 *
	 * Orientation: The head of the "T" typically faces enemy forces.
	 */
	static readonly AREA24: number;
	/**
	 * Anchor Points: This symbol requires three anchor points. Points 1 and 2
	 * define the end points of the symbol’s vertical line. Point 3 defines the
	 * tip of the longest arrow.
	 *
	 * Size/Shape: Points 1 and 2 determine the height of the symbol and
	 * point 3 determines its length. The spacing between the symbol’s arrows
	 * will stay proportional to the symbol’s vertical line. The length of the
	 * short arrows will remain in proportion to the length of the longest
	 * arrow. The arrows are perpendicular to the baseline (vertical line) and
	 * parallel to each other.
	 *
	 * Orientation: The arrows typically point toward enemy forces.
	 */
	static readonly AREA25: number;
	/**
	 * Anchor Points: This symbol requires a minimum of 6 anchor points. Add as
	 * many pairs of points as needed to accurately define the areas. The number
	 * of points shall always be an even number, with an equal number of points
	 * for both polygons. Points 1 through N/2 define the inner safe zone
	 * (zone 1). Points N/2 +1 though point N defines the outer zone (zone 2).
	 *
	 * Size/Shape: Determined by the anchor points.
	 *
	 * Orientation: The symbol will typically be oriented upright.
	 */
	static readonly AREA26: number;
	/**
	 * Anchor Points: This symbol requires one anchor point. The anchor point
	 * defines/is the tip of the inverted cone.
	 *
	 * Size/Shape: Static.
	 *
	 * Orientation: The symbol will typically be oriented upright.
	 */
	static readonly POINT1: number;
	/**
	 * Anchor Points: This symbol requires one anchor point. The center point
	 * defines/is the center of the symbol.
	 *
	 * Size/Shape: Static.
	 *
	 * Orientation: The symbol is typically centered over the desired location.
	 */
	static readonly POINT2: number;
	/**
	 * Anchor Points: This symbol requires one anchor point.
	 * The center point defines the center of the symbol.
	 *
	 * Size/Shape: Static. Maneuver area symbol shall be drawn with a black
	 * border. Maneuver areas may be either unfilled or filled with
	 * performance-contoured color options
	 *
	 * Orientation: The symbol is typically centered over the desired location.
	 */
	static readonly POINT3: number;
	/**
	 * Anchor Points: This symbol requires one anchor point. The point defines
	 * the bottom of the central vertical line in the symbol where the curved
	 * and vertical lines meet.
	 *
	 * Size/Shape: Static.
	 *
	 * Orientation: The symbol will typically be oriented upright (as shown in the template and example).
	 */
	static readonly POINT4: number;
	/**
	 * Anchor Points: This symbol requires one anchor point. The point defines
	 * the point where all the lines meet.
	 *
	 * Size/Shape: Static.
	 *
	 * Orientation: The symbol will typically be oriented upright (as shown in
	 * the example).
	 */
	static readonly POINT5: number;
	/**
	 * Anchor Points: This symbol requires one anchor point. The anchor point
	 * defines/is the center of the bottom of the control measure symbol as
	 * shown in the template and example.
	 *
	 * Size/Shape: Static.
	 *
	 * Orientation: The symbol will typically be oriented upright.
	 */
	static readonly POINT6: number;
	/**
	 * Anchor Points: This symbol requires one anchor point. The anchor point
	 * defines the midpoint of the symbol's base.
	 *
	 * Size/Shape: Static.
	 *
	 * Orientation: The symbol will typically be oriented upright (as shown in
	 * the template and example).
	 */
	static readonly POINT7: number;
	/**
	 * Anchor Points: This symbol requires one anchor point. The center point
	 * defines the center of the symbol.
	 *
	 * Size/Shape: Static. The symbol's corners form a 70- degree angle.
	 *
	 * Orientation: The symbol is typically centered over the desired location.
	 * A user can use this symbol to define a new type of point if the selection
	 * that follows is not sufficient.
	 */
	static readonly POINT8: number;
	/**
	 * Anchor Points: This symbol requires one anchor (center) point. The point
	 * defines the center of the symbol.
	 *
	 * Size/Shape: Static. The symbol's height should be 2x the symbol's width.
	 *
	 * Orientation: The symbol's center point is typically centered over the
	 * desired location. The symbol shall be oriented upright, as shown in the
	 * examples.
	 */
	static readonly POINT9: number;
	/**
	 * Anchor Points: This symbol requires one anchor point. The point defines
	 * the center of the circle. (Sonobuoy)
	 *
	 * Size/Shape: Static. The diameter of the circle should be 1/2 the height
	 * of the symbol.
	 *
	 * Orientation: The symbol's center point is typically centered over the
	 * desired location. The symbol will be oriented upright, as shown in the
	 * example.
	 */
	static readonly POINT10: number;
	/**
	 * Anchor Points: This symbol requires one center point. The point defines
	 * the center of the symbol.
	 *
	 * Size/Shape: Static. Length is 2x the size of height.
	 *
	 * Orientation: The symbol is centered over the desired location. The symbol
	 * shall be oriented upright, as shown in the example.
	 */
	static readonly POINT11: number;
	/**
	 * Anchor Points: This symbol requires three anchor points. Points 1 and 2
	 * define the tips of the arrowheads and point 3 defines the rear of the
	 * symbol.
	 *
	 * Size/Shape: Points 1 and 2 determine the symbol's height and point 3
	 * determines its length. The vertical line at the rear of the symbol shall
	 * be the same length as the opening, and shall be perpendicular to the
	 * parallel lines formed with the rear of symbol vertical line and the lines
	 * ending with points 1 and 2.
	 *
	 * Orientation: The opening typically faces the applicable obstacle.
	 */
	static readonly POINT12: number;
	/**
	 * Anchor Points: This symbol requires one anchor point. The center point
	 * defines the center of the circle.
	 *
	 * Size/Shape: Static.
	 *
	 * Orientation: The symbol is typically centered over the desired location.
	 */
	static readonly POINT13: number;
	/**
	 * Anchor Points: This symbol requires one anchor point. The center point
	 * defines the center of the symbol.
	 *
	 * Size/Shape: There should be 45 degrees of angular separation between the
	 * two arrows.
	 *
	 * Orientation: The symbol is typically centered over the desired location.
	 */
	static readonly POINT14: number;
	/**
	 * Anchor Points: This symbol requires one anchor point. The anchor point
	 * defines "nose" of the symbol.
	 *
	 * Size/Shape: Static.
	 *
	 * Orientation: The symbol is typically centered over the desired location.
	 */
	static readonly POINT15: number;
	/**
	 * Anchor Points: This symbol requires one anchor point; the point defines
	 * the circle at the base of the tower.
	 *
	 * Size/Shape: The symbol is a high-angle cone.
	 *
	 * Orientation: The symbol will remain upright.
	 */
	static readonly POINT16: number;
	/**
	 * Anchor Points: This symbol requires one anchor point. This anchor point
	 * represents the center of the rectangle and, therefore, the geographic
	 * location of that rectangle.
	 *
	 * Size/Shape: The size and shape of this symbol is determined by three
	 * additional numeric values; A length (AM1), a width (AM2), and a
	 * rotation angle. The length and width should be expressed in the
	 * appropriate map distance units. The length is aligned with the axis of
	 * rotation. The width is aligned perpendicular to the axis of rotation.
	 *
	 * Orientation: The orientation of this symbol is determined by the
	 * rotation angle provided, where 0 degrees is North and a positive
	 * rotation angle rotates the rectangle in a clockwise direction.
	 */
	static readonly POINT17: number;
	/**
	 * Anchor Points: This symbol requires one anchor point that defines the
	 * axis of angular rotation.
	 *
	 * Size/Shape: The size and shape of this symbol is determined by additional
	 * numeric values; A search axis azimuth, a start range, a stop range and a
	 * stop relative bearing. The stop relative bearing is an equal angle either
	 * side of the search axis. The start and stop range should be expressed in
	 * the appropriate map distance units. Field T should be positioned in the
	 * center of the search area aligned with the search axis.
	 *
	 * Orientation: The orientation of this symbol is determined by the search
	 * axis azimuth provided.
	 */
	static readonly POINT18: number;
	/**
	 * Anchor Points: This symbol requires at least two anchor points, points 1
	 * and 2, to define the line. Additional points can be defined to extend the
	 * line.
	 *
	 * Size/Shape: The first and last anchor points determine the length of the
	 * line.
	 *
	 * Orientation: Orientation is determined by the order in which the anchor points are entered.
	 */
	static readonly LINE1: number;
	/**
	 * Anchor Points: This symbol requires at least two anchor points, points
	 * 1 and 2, to define the line. Additional points can be defined to extend
	 * the line.
	 *
	 * Size/Shape: The first and last anchor points determine the length of the line.
	 * The end-of line information will typically be posted at the ends of the line
	 * as it is displayed on the screen.
	 *
	 * Orientation: Orientation is determined by the order in which the anchor points
	 * are entered.
	 */
	static readonly LINE2: number;
	/**
	 * Anchor Points: This symbol requires three anchor points. Point 1 defines
	 * the vertex of the symbol. Points 2 and 3 define the tips of the arrowheads.
	 *
	 * Size/Shape: The length and orientation of the arrows can vary
	 * independently.
	 *
	 * Orientation: Orientation is determined by the anchor points. The
	 * arrowheads may touch other symbols that define the limits of the task.
	 * The top of the tactical symbol indicator may touch point 1
	 */
	static readonly LINE3: number;
	/**
	 * Anchor Points: This symbol requires two anchor points. Points 1 and 2
	 * define the corner points of the symbol.
	 *
	 * Size/Shape: The symbol varies only in length.
	 *
	 * Orientation: Orientation is determined by the anchor points.
	 */
	static readonly LINE4: number;
	/**
	 * Anchor Points: This symbol requires two anchor points. Points 1 and 2
	 * define the endpoints of the symbol.
	 *
	 * Size/Shape: The symbol varies only in length.
	 *
	 * Orientation: One point defines the origin from which the bearing is being
	 * taken and the other point defines the location or direction from which a
	 * contact is made.
	 */
	static readonly LINE5: number;
	/**
	 * Anchor Points: This symbol requires 3 anchor points. Point 1 defines the
	 * vertex of the symbol and points 2 and 3 define its endpoints.
	 *
	 * Size/Shape: Points 1, 2 and 3 determine the length of the lines
	 * connecting them. The line defined by points 1 and 2 is typically the same
	 * length as the line between points 2 and 3.
	 *
	 * Orientation: Orientation is determined by the anchor points
	 */
	static readonly LINE6: number;
	/**
	 * Anchor Points: This symbol requires at least two anchor points, points
	 * 1 and 2, to define the line. Additional points can be defined to extend
	 * the line.
	 *
	 * Size/Shape: The first and last anchor points determine the length of the
	 * line. The line information will be posted once at the center of the line
	 * as it is displayed on the screen.
	 *
	 * Orientation: Orientation is determined by the order in which the anchor
	 * points are entered.
	 */
	static readonly LINE7: number;
	/**
	 * Anchor Points: This symbol requires a minimum of two (2) anchor points.
	 * Up to 298 additional points can be added to extend the line. The first
	 * point (point 1) defines the start point. The last point defines the
	 * endpoint. The points are numbered sequentially beginning with point one (1), in increments of one.
	 *
	 * Size/Shape: The anchor points define the size and shape.
	 *
	 * Orientation: The orientation is determined by the anchor points.
	 */
	static readonly LINE8: number;
	/**
	 * Anchor Points: This symbol requires 2 anchor points. Point 1 defines the
	 * tip of the arrowhead and point 2 defines the rear of the symbol.
	 *
	 * Size/Shape: Points 1 and 2 determine the length of the symbol, which
	 * varies only in length.
	 *
	 * Orientation: The orientation is determined by the anchor points.
	 */
	static readonly LINE9: number;
	/**
	 * Anchor Points: This symbol requires two anchor points. Point 1 defines
	 * the tip of the arrowhead and point 2 defines the rear of the symbol.
	 * Point 3 defines the 90 degree arc.
	 *
	 * Size/Shape: Points 1 and 2 are connected by a 90 degree arc. Point 3
	 * indicates on which side of the line the arc is placed.
	 *
	 * Orientation: The rear of the symbol identifies the enemy’s location and
	 * the arrow points in the direction the obstacle should force the enemy to
	 * turn.
	 */
	static readonly LINE10: number;
	/**
	 * Anchor Points: This symbol requires four points. Points 1 and 2 define
	 * one side of the gap and points 3 and 4 define the opposite side of the
	 * gap.
	 *
	 * Size/Shape. Determined by the anchor points.
	 *
	 * Orientation: Not applicable.
	 */
	static readonly LINE11: number;
	/**
	 * Anchor Points: This symbol requires three anchor points. Points 1 and 2
	 * define the endpoints of the symbol and point 3 defines the location of
	 * one side of the symbol.
	 *
	 * Size/Shape: Points 1 and 2 determine the centerline of the symbol and
	 * point 3 determines its width.
	 *
	 * Orientation: Orientation is determined by the anchor points.
	 */
	static readonly LINE12: number;
	/**
	 * Anchor Points: This symbol requires at least two anchor points, points 1
	 * and 2, to define the line. Additional points can be defined to extend the
	 * line.
	 *
	 * Size/Shape: The first and last anchor points determine the length of the
	 * line. The size of the tooth does not change.
	 *
	 * Orientation: Orientation is determined by the anchor points.
	 */
	static readonly LINE13: number;
	/**
	 * Anchor Points: This symbol requires two anchor points. Points 1 and 2
	 * define the tips of the arrowheads.
	 *
	 * Size/Shape: Points 1 and 2 determine the length of the symbol, which
	 * varies only in length. The lines of the arrowhead will form an acute
	 * angle.
	 *
	 * Orientation: Orientation is determined by the anchor points.
	 */
	static readonly LINE14: number;
	/**
	 * Anchor Points: This symbol requires two anchor points. Points 1 and 2
	 * define the length and orientation of the straight line (trip wire)
	 * portion of the symbol.
	 *
	 * Size/Shape: Points 1 and 2 determine the length and orientation of the
	 * line drawn from the physical mine to the end of the trip wire. The
	 * distance between the line connecting points 1 and 2 is the length of
	 * the trip wire connected to the mine.
	 *
	 * Orientation: Orientation is determined by the anchor points.
	 */
	static readonly LINE15: number;
	/**
	 * Anchor Points: This symbol requires four points. Points 1 and 2 define
	 * one side of the assault crossing site and points 3 and 4 define the
	 * opposite side of the assault crossing site.
	 *
	 * Size/Shape: Determined by the anchor points.
	 *
	 * Orientation: Not applicable.
	 */
	static readonly LINE16: number;
	/**
	 * Anchor Points. This symbol requires three anchor points. Points 1 and 2
	 * define the endpoints of the first line. Point 3 defines the location of
	 * the parallel line.
	 *
	 * Size/Shape: Points 1 and 2 determine the length of the symbol. Point 3
	 * determines its width.
	 *
	 * Orientation: Orientation is determined by the anchor points.
	 */
	static readonly LINE17: number;
	/**
	 * Anchor Points: This symbol requires two anchor points. Points 1 and two
	 * define the tips of the arrowheads.
	 *
	 * Size/Shape: Points 1 and 2 determine the length of the symbol, which
	 * varies only in length. The arrowheads will be filled-in versions of a
	 * common arrowhead.
	 *
	 * Orientation: Orientation is determined by the anchor points.
	 */
	static readonly LINE18: number;
	/**
	 * Anchor Points: This symbol requires two anchor points. Points 1 and two
	 * define the corners on the front of the symbol.
	 *
	 * Size/Shape: Points 1 and 2 determine the length of the symbol, which
	 * varies only in length.
	 *
	 * Orientation: Orientation is determined by the anchor points
	 */
	static readonly LINE19: number;
	/**
	 * Anchor Points: This graphic requires two anchor points. Point 1 defines
	 * the tip of the arrowhead, and point 2 defines the rear of the graphic.
	 *
	 * Size/Shape: Points 1 and 2 determine the length of the graphic, which
	 * varies only in length.
	 *
	 * Orientation: The arrow points to the location where the convoy has halted.
	 */
	static readonly LINE20: number;
	/**
	 * Anchor Points: This symbol requires at least two anchor points to define
	 * the line. Additional points can be defined to extend and shape the line.
	 *
	 * Size/Shape: The first and last anchor points determine the length of the
	 * line. The line segment between each pair of anchor points will repeat all
	 * information associated with the line segment.
	 *
	 * Orientation: Orientation is determined by the anchor points.
	 */
	static readonly LINE21: number;
	/**
	 * Anchor Points: This symbol requires three anchor points. Points 1 and 2
	 * define the endpoints of the symbol’s opening and point 3 defines the rear
	 * of the symbol.
	 *
	 * Size/Shape: Points 1 and 2 determine the symbol’s height and point 3
	 * determines its length. The vertical line at the rear of the symbol will
	 * be the same height as the opening and parallel to it.
	 *
	 * Orientation: The opening defines the span of the breach and typically
	 * faces enemy forces.
	 */
	static readonly LINE22: number;
	/**
	 * Anchor Points: This symbol requires three anchor points. Points 1 and 2
	 * define the endpoints of the symbol’s vertical line and point 3 defines
	 * the rear of the symbol.
	 *
	 * Size/Shape: Points 1 and 2 determine the symbol’s height and point 3
	 * determines its length. The spacing between the symbol’s arrows will stay
	 * proportional to the symbol’s height. The tip of the middle arrowhead will
	 * be at the midpoint of the vertical line. The arrows will stay
	 * perpendicular to the vertical line, regardless of the rotational
	 * orientation of the symbol as a whole.
	 *
	 * Orientation: The arrows typically point toward enemy forces.
	 */
	static readonly LINE23: number;
	/**
	 * Anchor Points: This symbol requires three anchor points. Point 1 defines
	 * the tip of the arrowhead. Point 2 defines the end of the straight line
	 * portion of the symbol. Point 3 defines the diameter and orientation of
	 * the 180 degree circular arc.
	 *
	 * Size/Shape: Points 1 and 2 determine the length of the straight line
	 * portion of the symbol.
	 * Point 3 defines which side of the line the arc is on and the diameter of
	 * the arc.
	 *
	 * Orientation: The arrow points in the direction of the action. The tip of
	 * the arrowhead may indicate the location where the action is to conclude.
	 * The unit’s current location is typically represented at the base of the
	 * arc. The 180 degree circular arc is always perpendicular to the line.
	 */
	static readonly LINE24: number;
	/**
	 * Anchor Points: This symbol requires exactly two anchor points. Point 1
	 * defines the tip of the arrowhead and point 2 defines the rear of the
	 * symbol.
	 *
	 * Size/Shape: Points 1 and 2 determine the length of the symbol, which
	 * varies only in length.
	 *
	 * Orientation: The arrow typically points in the direction of the action.
	 */
	static readonly LINE25: number;
	/**
	 * Anchor Points: Where four points are available Point 1 and Point 2 define
	 * the ends of one arrow and Point 3 and Point 4 define the ends of the
	 * other arrow. Point 1 and Point 4 define the ends of their respective
	 * arrowheads. Where three points are available Point 1 defines the vertex
	 * of the symbol. Points 2 and 3 define the tips of the arrowheads.
	 *
	 * Size/Shape: Where four points are available, Points 1 and 2 and Points
	 * 3 and 4 determine the length of the arrows. Where three points are
	 * available Points 1 and 2 and points 1 and 3 determine the length of the
	 * arrows. The length and orientation of the arrows can vary independently.
	 *
	 * Orientation: Orientation is determined by the anchor points.
	 * The arrowheads may touch other symbols that define the limits of the
	 * task. The tactical symbol indicator is centered between point 2 and
	 * point 3 when four points are in use or centered on Point 1 when three
	 * points are in use.
	 */
	static readonly LINE26: number;
	/**
	 * Anchor Points: Where four points are available Point 1 defines the center
	 * of the circle. Point 2 defines the radius of the circle. Point 3 defines
	 * the curvature of the arc. Point 4 defines the end of the arrow. Where
	 * three points are available Point 1 defines the center point of the
	 * circle. Point 2 defines the tip of the arrowhead. Point 3 defines the
	 * 90 degree arc.
	 *
	 * Size/Shape: Where four points are available, Points 1 and 2 define the
	 * size of the circle, which should be adjusted as needed to contain the
	 * unit assigned the task. Point 3 controls the curvature of the arc.
	 * Point 4 defines the end of the arrow. Where three points are available
	 * Points 1 and 2 are connected by a 90 degree arc. The circle will at least
	 * be large enough to accommodate a tactical symbol. Point 3 indicates on
	 * which side of the line the arc is placed.
	 *
	 * Orientation: The arrowhead identifies the location/object to be seized
	 * and the circle identifies the unit(s) assigned the task. See 5.3.11 for
	 * options to accommodate multiple units.
	 */
	static readonly LINE27: number;
	/**
	 * Anchor Points: This symbol requires 2 anchor points. Point 1 defines the
	 * tip of the arrowhead, and point 2 defines the rear of the symbol.
	 *
	 * Size/Shape: Points 1 and 2 determine the length of the symbol, which
	 * varies only in length.
	 *
	 * Orientation: The arrow typically points toward enemy forces with the tip
	 * of the arrowhead indicating the location of the action.
	 *
	 * Duplicate of Line9 so removed in 2525E
	 */
	static readonly LINE28: number;
	/**
	 * Anchor Points: This symbol requires three anchor points. Point 1 is the
	 * tip of the arrowhead. Points 2 and 3 define the endpoints of the curved
	 * line on the back side of the symbol.
	 *
	 * Size/Shape: Points 2 and 3 determine the length of the curved line on the
	 * back side of the symbol. The rear of the arrowhead line shall connect to
	 * the midpoint of the line between points 2 and 3. The arrowhead line shall
	 * be perpendicular to the line formed by points 2 and 3.
	 *
	 * Orientation: Orientation is determined by the anchor points. The back
	 * side of the symbol encompasses the ambush position, while the arrowhead
	 * typically points at the target.
	 */
	static readonly LINE29: number;
	/**
	 * Anchor Points: This symbol may contain multiple segments. Each segment
	 * requires 2 anchor points. Point numbers that define the trace of the
	 * segment are sequential beginning with point 1, in increments of 1, up to
	 * a max of 99 points. Each anchor point defines the endpoint of a segment’s
	 * center line. The anchor points are Air Control Points (ACP),
	 * Communications Checkpoints (CCP) or both.
	 *
	 * Size/Shape: Points 1 and 2 determine the length of a segment. The
	 * information field inside each segment should be moveable and scalable
	 * within each segment. The information box outside the symbol should be
	 * placed between points 1 and 2 in such a way it does not obscure the
	 * symbol.
	 *
	 * Orientation: The anchor points determine orientation.
	 */
	static readonly CORRIDOR1: number;
	/**
	 * Anchor Points: The symbol requires N anchor points, where N is between
	 * 3 and 50. Point 1 defines the tip of the arrowhead. Point N-1 defines
	 * the rear of the symbol. Point N defines the back of the arrowhead.
	 * Anchor points are numbered sequentially beginning with point number
	 * one (1), in increments of one (1).
	 *
	 * Size/Shape: Points 1 through N-1 and 2 determine the symbol’s center line
	 * and Point N determines the width. The crossover point on the symbol shall
	 * occur between Points 1 and 2.
	 *
	 * Orientation: The arrowhead typically points toward enemy forces.
	 */
	static readonly AXIS1: number;
	/**
	 * Anchor Points: The symbol requires N anchor points, where N is between 3
	 * and 50. Point 1 defines the tip of the arrowhead. Point N-1 defines the
	 * rear of the symbol. Point N defines the back of the arrowhead. Anchor
	 * points are numbered sequentially beginning with point number one (1), in
	 * increments of one (1).
	 *
	 * Size/Shape: Points 1 through N-1 and 2 determine the symbol’s center line
	 * and Point N determines the width.
	 *
	 * Orientation: The arrowhead typically points toward enemy forces.
	 */
	static readonly AXIS2: number;
	/**
	 * Anchor Points: This symbol requires three anchor points. Points 1 and 2
	 * define the endpoints of the infiltration lane and point 3 defines the
	 * width on one side of the lane.
	 *
	 * Size/Shape: Points 1 and 2 determine the center line of the symbol and
	 * point 3 determines the width of the infiltration lane. The rest of the
	 * symbol stays proportional to the length of the center line.
	 *
	 * Orientation: Orientation is determined by points 1 and 2.
	 */
	static readonly POLYLINE1: number;
	/**
	 * Anchor Points: This symbol requires one anchor point. This anchor point
	 * represents the center of an ellipse and, therefore, the geographic
	 * location of that ellipse.
	 *
	 * Size/Shape: The size and shape of this symbol is determined by three
	 * additional numeric values; A major axis radius, a minor axis radius, and
	 * a rotation angle. The radii should be expressed in the appropriate map
	 * distance units.
	 *
	 * Orientation: The orientation of this symbol is determined by the rotation
	 * angle provided, where 0 degrees is east/west and a positive rotation
	 * angle rotates the ellipse in a counter-clockwise direction.
	 */
	static readonly ELLIPSE1: number;
	/**
	 * Anchor Points: This symbol requires two anchor points and a width,
	 * defined in meters, to define the boundary of the area. Points 1 and 2
	 * will be located in the center of two opposing sides of the rectangle.
	 *
	 * Size/Shape: Size: As determined by the anchor points. The anchor points
	 * determine the length of the rectangle. The width, defined in meters,
	 * will determine the width of the rectangle. Shape: Rectangle. The
	 * information fields should be moveable and scalable.
	 *
	 * Orientation: As determined by the anchor points.
	 */
	static readonly RECTANGULAR1: number;
	/**
	 * Anchor Points: This symbol requires one (1) anchor point to define the
	 * center of the area.
	 *
	 * Size/Shape: Size Is determined by the anchor point, the target length
	 * (in meters) and target width (in meters). A rectangular target is wider
	 * and longer than 200 meters. The information fields should be moveable and
	 * saleable within the area. Shape: Rectangle.
	 *
	 * Orientation: As determined by the Target Attitude (in mils).
	 */
	static readonly RECTANGULAR2: number;
	/**
	 * Anchor Points: This symbol requires one anchor (center) point to define
	 * the center of the symbol. The target tactical symbol shall be centered
	 * upon the center of the area. The size and the orientation of the target
	 * symbol are fixed within the area.
	 *
	 * Size/Shape: As determined by the anchor points. The anchor points
	 * determine the area’s length.
	 * Width, determined in meters, will define the width of the rectangle.
	 *
	 * Orientation: As determined by the anchor points. The center point of the
	 * area shall always have the target symbol with the same
	 * upright orientation.
	 */
	static readonly RECTANGULAR3: number;
	/**
	 * Anchor Points: This symbol requires one (1) anchor point and a radius.
	 * Point 1 defines the center point of the symbol.
	 *
	 * Size/Shape: Size: The radius defines the size. Shape: Circle. The
	 * information fields should be scalable within the circle.
	 *
	 * Orientation: Not applicable
	 */
	static readonly CIRCULAR1: number;
	/**
	 * Anchor Points: This symbol requires one anchor point that defines an
	 * object at a dynamic grid location. This coordinate, which pinpoints the
	 * current physical location of a specific unit, weapon or acquisition
	 * system, may change with the movement of the object. The symbol for that
	 * object is located at the anchor point.
	 *
	 * Size/Shape: The size is determined by the distance in meters from the
	 * object at the center of the range fan. The shapes are concentric circles.
	 * A minimum of one (1) and a maximum of three (3) concentric circles can be
	 * used.
	 *
	 * Orientation: The center point is typically centered over the known
	 * location of a weapon or sensor system.
	 */
	static readonly CIRCULAR2: number;
	/**
	 * Anchor Points: This graphic requires one anchor point that defines an
	 * object at a dynamic grid location. This coordinate, which pinpoints the
	 * current physical location of a specific unit, weapon or sensor system,
	 * may change with the movement of the object. The symbol for that object
	 * is located at the anchor point.
	 *
	 * Size/Shape: Determined by the anchor point, azimuths measured from true
	 * north, and the distance (range) in meters. The Left Sector Azimuth is the
	 * angle measured from true north to the left sector limit/edge of the
	 * Sector Range Fan. The Right Sector Azimuth is the angle measured from
	 * true north to the right sector limit/edge of the Sector Range Fan.
	 * Multiple distances (ranges) and/or left and right sector limits/edges
	 * of the sector, as well as altitude, may be added as required to define
	 * the sector. All azimuths are in degrees. All distances (ranges) are in
	 * meters. All altitudes are in feet.
	 *
	 * Orientation: The center point is typically centered over the known
	 * location of a weapon or sensor system. The orientation may change as
	 * the object moves or changes.
	 */
	static readonly ARC1: number;
}
/**
 * Draw Rules for METEOROLOGICAL AND OCEANOGRAPHIC SYMBOLOGY
 *
 */
export declare class MODrawRules {
	/**
	 * Usually an entry in the MilStd that is just a category containing other symbols
	 * and not something that gets drawn itself.
	 */
	static readonly DONOTDRAW: number;
	/**
	 * Anchor Points: This graphic requires at least three anchor points to
	 * define the boundary of the area. Add as many points as necessary to
	 * accurately reflect the area's size and shape.
	 * Size/Shape: Scalable.
	 * Orientation: Not applicable.
	 */
	static readonly AREA1: number;
	/**
	 * Anchor Points: This graphic requires at least three anchor points to
	 * define the boundary of the area. Add as many points as necessary to
	 * accurately reflect the area's size and shape.
	 * Size/Shape: Determined by the anchor points.
	 * Orientation: Not applicable.
	 */
	static readonly AREA2: number;
	/**
	 * Anchor Points: This graphic requires one anchor point. The center point
	 * defines the center of the graphic.
	 * Size/Shape: Scalable.
	 * Orientation: The graphic is typically centered over the desired location.
	 */
	static readonly POINT1: number;
	/**
	 * Anchor Points: This graphic requires one anchor point. The center point
	 * defines the geometric center of the graphic.
	 * Size/Shape: Scalable.
	 * Orientation: The graphic is centered over the anchor location.
	 */
	static readonly POINT2: number;
	/**
	 * Anchor Points: This graphic requires one anchor point. The center point
	 * defines the center of the graphic.
	 * Size/Shape: Scalable.
	 * Orientation: The graphic is oriented upright on the display and operator-centered over the desired location.
	 */
	static readonly POINT3: number;
	/**
	 * Anchor Points: This graphic requires one anchor point. The center point
	 * defines the center of the graphic.
	 * Size/Shape: Scalable.
	 * Orientation: The graphic is centered over the location of the reported wind.
	 */
	static readonly POINT4: number;
	/**
	 * Anchor Points: This graphic requires a minimum of two anchor points.
	 * The first point defines the location of the plot circle.
	 * Additional points define the wind shaft and the speed of the wind.
	 * Wind speed is depicted on the shaft using a combination of the shaft
	 * alone (1-2 knots), half barbs (5 knots), barbs (10 knots)
	 * and pennants (50 knots). Wind speeds 5 knots or greater are rounded
	 * to the nearest 5 knots. Missing wind speed is depicted by an "X" at
	 * the end of the wind shaft. Winds with missing direction are not displayed.
	 *
	 * Size/Shape: Not applicable.
	 *
	 * Orientation: The shaft of the graphic is oriented with reference to
	 * true north in the direction from which the wind is blowing to the
	 * nearest 10 degrees. The barbs and pennants lie back from the shaft at
	 * an angle of 120 degrees and are oriented to the left of the shaft in
	 * the Northern Hemisphere and to the right in the Southern Hemisphere.
	 * The graphic is operator-centered over the desired location.
	 */
	static readonly POINT5: number;
	/**
	 * Anchor Points: This graphic requires one anchor point. The center point
	 * defines the center of the graphic.
	 * Size/Shape: Scalable.
	 * Orientation: The graphic is centered over the location of the reported cloud cover.
	 */
	static readonly POINT6: number;
	/**
	 * Anchor Points: This graphic requires one anchor point. The center point
	 * defines the center of the graphic.
	 * Size/Shape: Scalable.
	 * Orientation: The graphic is centered over the location of the reported conditions.
	 */
	static readonly POINT7: number;
	/**
	 * Anchor Points: This graphic requires one anchor point. The center point
	 * defines the center of the graphic.
	 * Size/Shape: Scalable.
	 * Orientation: The graphic is centered over the position of the tropical system.
	 */
	static readonly POINT8: number;
	/**
	 * Anchor Points: This graphic requires at least two anchor points,
	 * points 1 and 2, to define the line. Additional points can be defined
	 * to extend the line.
	 * Size/Shape: Scalable/Curve. The curvature of the line is operator defined.
	 * Orientation: The first and last anchor points determine the length of
	 * the line.
	 */
	static readonly LINE1: number;
	/**
	 * Anchor Points: This graphic requires at least two anchor points,
	 * points 1 and 2, to define the line. Additional points can be defined to
	 * extend the line.
	 *
	 * Size/Shape: Scalable/Curve. The points are typically connected with a
	 * straight line consisting of a short line section and an alternating
	 * V shape. The curvature and amplitude of the waves of the line is
	 * operator defined.
	 *
	 * Orientation: The first and last anchor points determine the length of
	 * the line. The line should be drawn so the "V" shapes are facing in
	 * the direction of movement. The "V" shapes and short line segment will
	 * alternate along the line.
	 */
	static readonly LINE2: number;
	/**
	 * Anchor Points: This graphic requires at least two anchor points,
	 * points 1 and 2, to define the line. Additional points can be defined to
	 * extend the line.
	 *
	 * Size/Shape: Scalable/Curve. The points are typically connected with a
	 * straight line consisting of a short line section and alternating two
	 * dots. The curvature and amplitude of the waves of the line is
	 * operator defined.
	 *
	 * Orientation: The first and last anchor points determine the length of the line. The two dots and the short line segment will alternate along the line.
	 */
	static readonly LINE3: number;
	/**
	 * Anchor Points: This graphic requires at least two anchor points,
	 * points 1 and 2, to define the line. Additional points can be defined to
	 * extend the line.
	 *
	 * Size/Shape: Scalable/Curve. The points are typically connected with a
	 * curved/wavy line consisting of a short line and one dot. The curvature
	 * and amplitude of the waves of the line is operator defined.
	 *
	 * Orientation: The first and last anchor points determine the length of
	 * the line. The dot and the short line segment will alternate along
	 * the line.
	 */
	static readonly LINE4: number;
	/**
	 * Anchor Points: This graphic requires at least three anchor points to
	 * define the boundary of the area. Add as many points as necessary to
	 * accurately reflect the area's size and shape.
	 *
	 * Size/Shape: Determined by the anchor points.
	 *
	 * Orientation: The first and last anchor points determine the length of
	 * the line. The dual line segments will be parallel to slightly wider at
	 * the western end.
	 */
	static readonly LINE5: number;
	/**
	 * Anchor Points: This graphic requires at least two anchor points,
	 * points 1 and 2, to define the line. Additional points can be defined to
	 * extend the line.
	 * Size/Shape: Scalable/Curve. The points are typically connected with a
	 * solid straight line with alternating slanted lines connected as depicted
	 * in the example to indicate convergence.
	 * Orientation: The first and last anchor points determine the length of
	 * the line. The alternating slanted lines will be evenly spaced along
	 * the line. Orientation is determined by the anchor points.
	 */
	static readonly LINE6: number;
	/**
	 * Anchor Points: This graphic requires at least two anchor points,
	 * points 1 and 2, to define the line. Additional points can be defined to
	 * extend the line.
	 *
	 * Size/Shape: Scalable/Curve. The points are typically connected with a
	 * dashed straight or curved line. The curvature of the line is operator
	 * defined.
	 *
	 * Orientation: The first and last anchor points determine the length of
	 * the line. The red and green line segments will alternate along the line.
	 * Orientation is determined by the anchor points.
	 */
	static readonly LINE7: number;
	/**
	 * Anchor Points: This graphic requires at least two anchor points,
	 * points 1 and 2, to define the line. Additional points can be defined to
	 * extend the line.
	 * Size/Shape: Scalable.
	 * Orientation: The graphic is oriented upright on the display as shown in
	 * the example and operator-centered over the desired location.
	 */
	static readonly LINE8: number;
}
/**
 * Utility class that takes the 3 digit country code from the symbol ID and returns the 3 character string representation
 * of that country. For example, 840 turns into "USA" for the United States.
 */
export declare class GENCLookup {
	private static gencJSON;
	private static _instance;
	private static _initCalled;
	private static _isReady;
	private static _GENCLookup;
	private static genc;
	static loadData(location?: string): Promise<void>;
	private constructor();
	static getInstance(): GENCLookup;
	isReady(): boolean;
	private init;
	get3CharCode(id: number): string;
}
/**
 * This class holds information about the MilStd Symbol.
 * Name, geometry, point count, Draw Rule, etc...
 * Can be retrived from {@link MSLookup}.
 */
export declare class MSInfo {
	private _Version;
	private _Name;
	private _Path;
	private _SymbolSet;
	private _SymbolSetInt;
	private _EntityCode;
	private _Geometry;
	private _Modifiers;
	private _MinPointCount;
	private _MaxPointCount;
	private _DrawRule;
	/**
	 * @param version SymbolID.Version_2525Dch1 (11), SymbolID.Version_2525E (13)
	 * @param symbolSet the 5th &amp; 6th character in the symbol Code, represents Battle Dimension
	 * @param entity descriptor
	 * @param entityType descriptor
	 * @param entitySubType  descriptor
	 * @param entityCode characters 11 - 16 in the symbol code
	 * @param modifiers String[] of modifier codes
	 */
	constructor(version: number, symbolSet: string, entity: string, entityType: string, entitySubType: string, entityCode: string, modifiers: Array<string>);
	/**
	 * @param version SymbolID.Version_2525Dch1 (11), SymbolID.Version_2525E (13)
	 * @param symbolSet the 5th &amp; 6th character in the symbol Code, represents Battle Dimension
	 * @param entity descriptor
	 * @param entityType descriptor
	 * @param entitySubType  descriptor
	 * @param entityCode characters 11 - 16 in the symbol code
	 * @param geometry "point", "line", "area"
	 * @param drawRule as defined in 2525D for Control Measures and METOC (i.e. "Point1")
	 * @param modifiers ArrayList of modifiers that are allowed for this symbol
	 */
	constructor(version: number, symbolSet: string, entity: string, entityType: string, entitySubType: string, entityCode: string, geometry: string, drawRule: string, modifiers: Array<string>);
	private parseDrawRule;
	static parseSymbolSetName(symbolID: string): string;
	static parseSymbolSetName(ss: string, version: number): string;
	/**
	 *
	 * @param drawRule - Like DrawRules.CIRCULAR2
	 * @return int[] where the first index is the minimum required points and
	 * the next index is the maximum allowed points
	 */
	private static getMinMaxPointsFromDrawRule;
	private static getMinMaxPointsFromMODrawRule;
	getVersion(): number;
	getName(): string;
	getPath(): string;
	getGeometry(): string;
	getDrawRule(): number;
	getSymbolSet(): number;
	getEntityCode(): number;
	getBasicSymbolID(): string;
	getMinPointCount(): number;
	getMaxPointCount(): number;
	getModifiers(): Array<string>;
}
/**
 * Class that holds all the  objects with symbol information
 */
export declare class MSLookup {
	private static mse;
	private static msd;
	private static _instance;
	private static _initCalled;
	private static _isReady;
	private static _MSLookupD;
	private static _MSLookupE;
	private _IDListD;
	private _IDListE;
	private static msdJSON;
	private static mseJSON;
	static loadData(location?: string): Promise<void>;
	private constructor();
	static getInstance(): MSLookup;
	private init;
	isReady(): boolean;
	private populateLookup;
	private populateModifierList;
	/**
	 * @param symbolID Full 20-30 digits from the symbol code
	 * @return
	 */
	getMSLInfo(symbolID: string): MSInfo;
	/**
	 * @param basicID id SymbolSet + Entity code like 50110100
	 * @param version like SymbolID.Version_2525Dch1
	 * @return
	 */
	getMSLInfo(basicID: string, version: number): MSInfo;
	/**
	 * returns a list of all the keys in the order they are listed in the MilStd 2525D document.
	 * @param version see {@link SymbolID.Version_2525E} and {@link SymbolID.Version_2525Dch1}
	 * @return
	 */
	getIDList(version: number): Array<string>;
	addCustomSymbol(msInfo: MSInfo): boolean;
}
export declare class SVGInfo {
	private _ID;
	private _Bbox;
	private _SVG;
	constructor(id: string, measurements: Rectangle2D, svg: string);
	getID(): string;
	getBbox(): Rectangle2D;
	getSVG(): string;
	toString(): string;
}
export interface SymbolDimensionInfo {
	/**
	 * The x value the image should be centered on or the "anchor point".
	 * @return {@link Integer}
	 */
	getSymbolCenterX(): number;
	/**
	 * The y value the image should be centered on or the "anchor point".
	 * @return {@link Integer}
	 */
	getSymbolCenterY(): number;
	/**
	 * The point the image should be centered on or the "anchor point".
	 * @return {@link Point2D}
	 */
	getSymbolCenterPoint(): Point2D;
	/**
	 * minimum bounding rectangle for the core symbol. Does
	 * not include modifiers, display or otherwise.
	 * @return {@link Rectangle2D}
	 */
	getSymbolBounds(): Rectangle2D;
	/**
	 * Dimension of the entire image.
	 * @return {@link Rectangle2D}
	 */
	getImageBounds(): Rectangle2D;
}
export declare class SVGSymbolInfo implements SymbolDimensionInfo {
	private _svg;
	private _svgDataURI;
	private _anchorX;
	private _anchorY;
	private _symbolBounds;
	private _bounds;
	constructor(svg: string, anchorPoint: Point2D, symbolBounds: Rectangle2D, svgBounds: Rectangle2D);
	private bytesToBase64;
	private escapeChars;
	getSVGDataURI(): string;
	getSVG(): string;
	/**
	 * The x value the image should be centered on or the "anchor point".
	 * @return
	 */
	getSymbolCenterX(): int;
	/**
	 * The y value the image should be centered on or the "anchor point".
	 * @return
	 */
	getSymbolCenterY(): int;
	/**
	 * The point the image should be centered on or the "anchor point".
	 * @return
	 */
	getSymbolCenterPoint(): Point2D;
	/**
	 * minimum bounding rectangle for the core symbol. Does
	 * not include modifiers, display or otherwise.
	 * @return
	 */
	getSymbolBounds(): Rectangle2D;
	/**
	 * Dimension of the entire image.
	 * @return
	 */
	getImageBounds(): Rectangle2D;
}
/**
 * Has various utility functions for prcessing the symbol code.
 * See {@link SymbolID} for additional functions related to parsing the symbol code.
 *
 */
export declare class SymbolUtilities {
	private static readonly Digits;
	private static readonly HexDigits;
	private static readonly Exp;
	private static readonly fpRegex;
	private static readonly pIsNumber;
	/**
	 * Determines if a String represents a valid number
	 *
	 * @param text string
	 * @return "1.56" == true, "1ab" == false
	 */
	static isNumber(text: string): boolean;
	/**
	 * Converts a Java Date object into a properly formatted String for W or W1.
	 * DDHHMMSSZMONYYYY
	 * Field W: D = day, H = hour, M = minute, S = second, Z = Greenwich or local time, MON= month and Y = year.
	 * @param date {@link Date}
	 * @return string
	 */
	static getDateLabel(date: Date): string;
	/**
	 * Given date, return character String representing which NATO time zone
	 * you're in.
	 *
	 * @param time {@link Date}
	 * @return string
	 */
	private static getZuluCharFromTimeZoneOffset;
	/**
	 * Determines if a symbol, based on it's symbol ID, can have the specified modifier/amplifier.
	 * @param symbolID 30 Character string
	 * @param modifier {@link Modifiers}
	 * @return
	 */
	static hasModifier(symbolID: string, modifier: string): boolean;
	/**
	 * Gets Basic Symbol ID which is the Symbol Set + Entity Code
	 * @param id 30 Character string
	 * @return 8 character string (Symbol Set + Entity Code)
	 */
	static getBasicSymbolID(id: string): string;
	/**
	 * Gets the basic Symbol ID for a 2525C symbol
	 * S*F*GPU---*****
	 * G*G*GPP---****X
	 * @param strSymbolID 15 Character string
	 * @return 15 Character string
	 * @deprecated function will be removed
	 */
	static getBasicSymbolID2525C(strSymbolID: string): string;
	/**
	 * Attempts to resolve a bad symbol ID into a value that can be found in {@link MSLookup}.
	 * If it fails, it will return the symbol code for a invalid symbol which is displayed as
	 * an inverted question mark (110098000010000000000000000000)
	 * @param symbolID 30 character string
	 * @return 30 character string representing the resolved symbol ID.
	 */
	static reconcileSymbolID(symbolID: string): string;
	/**
	 * Gets line color used if no line color has been set. The color is specified based on the affiliation of
	 * the symbol and whether it is a unit or not.
	 * @param symbolID 30 character string
	 * @return
	 */
	static getLineColorOfAffiliation(symbolID: string): Color | null;
	/**
	 * For Control Measures, returns the default color for a symbol when it differs from the
	 * affiliation line color.  If there is no default color, returns the value from {@link getLineColorOfAffiliation()}
	 * @param symbolID 30 Character string
	 * @return
	 */
	static getDefaultLineColor(symbolID: string): Color | null;
	/**
	 * Checks if a symbol should be filled by default
	 *
	 * @param strSymbolID The 20 digit representation of the 2525D symbol
	 * @return true if there is a default fill
	 */
	static hasDefaultFill(strSymbolID: string): boolean;
	/**
	 * Determines if the symbol is a tactical graphic
	 *
	 * @param strSymbolID 30 Character string
	 * @return true if symbol set is 25 (control measure), or is a weather graphic
	 */
	static isTacticalGraphic(strSymbolID: string): boolean;
	/**
	 * Determines if the Symbol can be rendered as a multipoint graphic and not just as an icon
	 * @param symbolID 30 Character string
	 * @return
	 */
	static isMultiPoint(symbolID: string): boolean;
	static isActionPoint(symbolID: string): boolean;
	/**
	 * Control Measures and Tactical Graphics that have labels but not with the Action Point layout
	 * @param strSymbolID 30 Character string
	 * @return
	 * @deprecated see {@link isSPWithSpecialModifierLayout(String)}
	 */
	static isTGSPWithSpecialModifierLayout(strSymbolID: string): boolean;
	/**
	 * Returns the fill color for the symbol based on its affiliation
	 * @param symbolID 30 Character string
	 * @return
	 */
	static getFillColorOfAffiliation(symbolID: string): Color | null;
	/**
	 *
	 * @param symbolID 30 Character string
	 * @param modifier {@link Modifiers}
	 * @return
	 * @deprecated see {@link hasModifier()}
	 */
	static canSymbolHaveModifier(symbolID: string, modifier: string): boolean;
	/**
	 * Checks if the Symbol Code has FDI set.
	 * Does not check if the symbol can have an FDI.
	 * @param symbolID 30 Character string
	 * @return
	 */
	static hasFDI(symbolID: string): boolean;
	/**
	 * Returns true if graphic is protection graphic (obstacles which render green)
	 * @param symbolID 30 Character string
	 * @return
	 */
	static isGreenProtectionGraphic(symbolID: string): boolean;
	/***
	 * Returns true if graphic is protection graphic (obstacles which render green)
	 * Assumes control measure symbol code where SS == 25
	 * @param entity
	 * @param entityType
	 * @param entitySubtype
	 * @return
	 */
	static isGreenProtectionGraphic(entity: int, entityType: int, entitySubtype: int): boolean;
	/**
	 * Returns true if Symbol ID represents a chemical, biological, radiological or nuclear incident.
	 * @param symbolID 30 Character string
	 * @return
	 */
	static isCBRNEvent(symbolID: string): boolean;
	/**
	 * Returns true if Symbol ID represents a Sonobuoy.
	 * @param symbolID 30 Character string
	 * @return
	 */
	static isSonobuoy(symbolID: string): boolean;
	/**
	 * Obstacles are generally required to have a green line color
	 * @param symbolID 30 Character string
	 * @return
	 * @deprecated see {@link isGreenProtectionGraphic()}
	 */
	static isObstacle(symbolID: string): boolean;
	/**
	 * Return true if symbol is from the Atmospheric, Oceanographic or Meteorological Space Symbol Sets.
	 * @param symbolID 30 Character string
	 * @return
	 */
	static isWeather(symbolID: string): boolean;
	/**
	 * Returns true if the symbol has the HQ staff indicated by the symbol ID
	 * @param symbolID 30 Character string
	 * @return
	 */
	static isHQ(symbolID: string): boolean;
	/**
	 * Checks if this is a single point control measure or meteorological graphic with a unique layout.
	 * Basically anything that's not an action point style graphic with modifiers
	 * @param symbolID 30 Character string
	 * @return
	 */
	static isSPWithSpecialModifierLayout(symbolID: string): boolean;
	/**
	 * Gets the anchor point for single point Control Measure as the anchor point isn't always they center of the symbol.
	 * @param symbolID 30 Character string
	 * @param bounds {@link Rectangle2D} representing the bound of the core symbol in the image.
	 * @return  representing the point in the image that is the anchor point of the symbol.
	 */
	static getCMSymbolAnchorPoint(symbolID: string, bounds: Rectangle2D): Point;
	/**
	 * Returns true if the symbol is an installation
	 * @param symbolID 30 Character string
	 * @return
	 */
	static isInstallation(symbolID: string): boolean;
	/**
	 * Returns true if the symbol is from an air based symbol set
	 * @param symbolID 30 Character string
	 * @return
	 */
	static isAir(symbolID: string): boolean;
	/**
	 * Returns true if the symbol is from a space based symbol set
	 * @param symbolID 30 Character string
	 * @return
	 */
	static isSpace(symbolID: string): boolean;
	/**
	 * Returns true if the symbol is from a land based symbol set
	 * @param symbolID 30 Character string
	 * @return
	 */
	static isLand(symbolID: string): boolean;
	/**
	 * Returns true if the symbol ID has the task for indicator
	 * @param symbolID 30 Character string
	 * @return
	 */
	static isTaskForce(symbolID: string): boolean;
	/**
	 * Returns true if the symbol ID indicates the context is Reality
	 * @param symbolID 30 Character string
	 * @return
	 */
	static isReality(symbolID: string): boolean;
	/**
	 * Returns true if the symbol ID indicates the context is Exercise
	 * @param symbolID 30 Character string
	 * @return
	 */
	static isExercise(symbolID: string): boolean;
	/**
	 * Returns true if the symbol ID indicates the context is Simulation
	 * @param symbolID 30 Character string
	 * @return
	 */
	static isSimulation(symbolID: string): boolean;
	/**
	 * Reads the Symbol ID string and returns the text that represents the echelon
	 * code.
	 * @param echelon  from positions 9-10 in the symbol ID
	 * See {@link SymbolID.getAmplifierDescriptor()}
	 * @return string (23 (Army) would be "XXXX")
	 */
	static getEchelonText(echelon: int): string;
	/**
	 * Returns the Standard Identity Modifier based on the Symbol ID
	 * @param symbolID 30 Character string
	 * @return string
	 */
	static getStandardIdentityModifier(symbolID: string): string;
	/**
	 * Returns true if the unit has a rectangle frame
	 * @param symbolID 30 Character string
	 * @return
	 */
	static hasRectangleFrame(symbolID: string): boolean;
	/**
	 * Returns the height ratio for the unit specified by the symbol ID
	 * Based on Figure 4 in 2525E.
	 * @param symbolID 30 Character string
	 * @return
	 */
	static getUnitRatioHeight(symbolID: string): double;
	/**
	 * Returns the width ratio for the unit specified by the symbol ID
	 * Based on Figure 4 in 2525E.
	 * @param symbolID 30 Character string
	 * @return
	 */
	static getUnitRatioWidth(symbolID: string): double;
}
export interface SettingsEventListener {
	SettingsEventChanged(type: string): void;
}
/**
 *Static class that holds the setting for the JavaRenderer.
 * Allows different parts of the renderer to know what
 * values are being used.
 *
 */
export declare class RendererSettings {
	private static _instance;
	private static _TextBackgroundMethod;
	/**
	 * There will be no background for text
	 */
	static readonly TextBackgroundMethod_NONE: int;
	/**
	 * There will be a colored box behind the text
	 */
	static readonly TextBackgroundMethod_COLORFILL: int;
	/**
	 * There will be an adjustable outline around the text (expensive)
	 * Outline width of 4 is recommended.
	 */
	static readonly TextBackgroundMethod_OUTLINE: int;
	/**
	 * A different approach for outline which is quicker and seems to use
	 * less memory.  Also, you may do well with a lower outline thickness setting
	 * compared to the regular outlining approach.  Outline Width of 1 is
	 * recommended.
	 */
	static readonly TextBackgroundMethod_OUTLINE_QUICK: int;
	/**
	 * Value from 0 to 255. The closer to 0 the lighter the text color has to be
	 * to have the outline be black. Default value is 160.
	 */
	private static _TextBackgroundAutoColorThreshold;
	private static _TextOutlineWidth;
	private static _ColorLabelForeground;
	private static _ColorLabelBackground;
	private static _PixelSize;
	/**
	 * Collapse labels for fire support areas when the symbol isn't large enough to show all
	 * the labels.
	 */
	private static _AutoCollapseModifiers;
	/**
	 * @deprecated
	 */
	private static _SymbolOutlineWidth;
	private static _OutlineSPControlMeasures;
	private static _ActionPointDefaultFill;
	/**
	 * If true (default), when HQ Staff is present, location will be indicated by the free
	 * end of the staff
	 */
	private static _CenterOnHQStaff;
	static OperationalConditionModifierType_SLASH: int;
	static OperationalConditionModifierType_BAR: int;
	private static _OCMType;
	static readonly SeaMineRenderMethod_MEDAL: int;
	static readonly SeaMineRenderMethod_ALT: int;
	static _SeaMineRenderMethod: int;
	private static _UseLineInterpolation;
	private static _ModifierFontName;
	private static _ModifierFontType;
	private static _ModifierFontWeight;
	private static _ModifierFontSize;
	private static _ModifierFontKerning;
	private static _ModifierFontTracking;
	private _scaleEchelon;
	private _DrawAffiliationModifierAsLabel;
	private static _MPLabelFontName;
	private static _MPLabelFontType;
	private static _MPLabelFontSize;
	private static _KMLLabelScale;
	private static _DPI;
	private _TwoLabelOnly;
	private _scaleMainIconWithoutSectorMods;
	private _friendlyUnitFillColor;
	private _hostileUnitFillColor;
	private _neutralUnitFillColor;
	private _unknownUnitFillColor;
	private _friendlyGraphicFillColor;
	private _hostileGraphicFillColor;
	private _neutralGraphicFillColor;
	private _unknownGraphicFillColor;
	private _friendlyUnitLineColor;
	private _hostileUnitLineColor;
	private _neutralUnitLineColor;
	private _unknownUnitLineColor;
	private _friendlyGraphicLineColor;
	private _hostileGraphicLineColor;
	private _neutralGraphicLineColor;
	private _unknownGraphicLineColor;
	private _Listeners;
	private constructor();
	static getInstance(): RendererSettings;
	private Init;
	addEventListener(sel: SettingsEventListener): void;
	private raiseEvents;
	/**
	 * None, outline (default), or filled background.
	 * If set to OUTLINE, TextOutlineWidth changed to default of 4.
	 * If set to OUTLINE_QUICK, TextOutlineWidth changed to default of 1.
	 * Use setTextOutlineWidth if you'd like a different value.
	 * @param textBackgroundMethod like RenderSettings.TextBackgroundMethod_NONE
	 */
	setTextBackgroundMethod(textBackgroundMethod: int): void;
	/**
	 * None, outline (default), or filled background.
	 * @return method like RenderSettings.TextBackgroundMethod_NONE
	 */
	getTextBackgroundMethod(): int;
	/**
	 * default size single point icons will render on the map
	 * @param size
	 */
	setDefaultPixelSize(size: int): void;
	/**
	 * default size single point icons will render on the map
	 * @return
	 */
	getDefaultPixelSize(): int;
	/**
	 * Set the operational condition modifier to be slashes or bars
	 * @param value like RendererSettings.OperationalConditionModifierType_SLASH
	 */
	setOperationalConditionModifierType(value: int): void;
	getOperationalConditionModifierType(): int;
	setSeaMineRenderMethod(method: int): void;
	getSeaMineRenderMethod(): int;
	/**
	 * For lines symbols with "decorations" like FLOT or LOC, when points are
	 * too close together, we will start dropping points until we get enough
	 * space between 2 points to draw the decoration.  Without this, when points
	 * are too close together, you run the chance that the decorated line will
	 * look like a plain line because there was no room between points to
	 * draw the decoration.
	 * @param value boolean
	 */
	setUseLineInterpolation(value: boolean): void;
	/**
	 * Returns the current setting for Line Interpolation.
	 * @return boolean
	 */
	getUseLineInterpolation(): boolean;
	/**
	 * set the screen DPI so the renderer can take DPI into account when
	 * rendering for things like dashed lines and decorated lines.
	 * @param value
	 */
	setDeviceDPI(value: int): void;
	getDeviceDPI(): int;
	/**
	 * Collapse Modifiers for fire support areas when the symbol isn't large enough to show all
	 * the labels.  Identifying label will always be visible.  Zooming in, to make the symbol larger,
	 * will make more modifiers visible.  Resizing the symbol can also make more modifiers visible.
	 * @param value boolean
	 */
	setAutoCollapseModifiers(value: boolean): void;
	getAutoCollapseModifiers(): boolean;
	/**
	 * if true (default), when HQ Staff is present, location will be indicated by the free
	 * end of the staff
	 * @param value
	 */
	setCenterOnHQStaff(value: boolean): void;
	/**
	 * if true (default), when HQ Staff is present, location will be indicated by the free
	 * end of the staff
	 */
	getCenterOnHQStaff(): boolean;
	/**
	 * if RenderSettings.TextBackgroundMethod_OUTLINE is used,
	 * the outline will be this many pixels wide.
	 *
	 * @param width
	 * @deprecated - controlled within the renderer
	 */
	/**
	 * if RenderSettings.TextBackgroundMethod_OUTLINE is used,
	 * the outline will be this many pixels wide.
	 * @return
	 */
	getTextOutlineWidth(): int;
	/**
	 * Refers to text color of modifier labels
	 * @return
	 *
	 */
	/**
	 * Refers to text color of modifier labels
	 * Default Color is Black.  If NULL, uses line color of symbol
	 * @param value
	 *
	 */
	/**
	 * Refers to background color of modifier labels
	 * @return
	 *
	 */
	/**
	 * Refers to text color of modifier labels
	 * Default Color is White.
	 * Null value means the optimal background color (black or white)
	 * will be chose based on the color of the text.
	 * @param value
	 *
	 */
	/**
	 * Value from 0 to 255. The closer to 0 the lighter the text color has to be
	 * to have the outline be black. Default value is 160.
	 * @param value
	 */
	setTextBackgroundAutoColorThreshold(value: int): void;
	/**
	 * Value from 0 to 255. The closer to 0 the lighter the text color has to be
	 * to have the outline be black. Default value is 160.
	 * @return
	 */
	getTextBackgroundAutoColorThreshold(): int;
	/**
	 * This applies to Single Point Tactical Graphics.
	 * Setting this will determine the default value for milStdSymbols when created.
	 * 0 for no outline,
	 * 1 for outline thickness of 1 pixel,
	 * 2 for outline thickness of 2 pixels,
	 * greater than 2 is not currently recommended.
	 * @deprecated
	 * @param width
	 */
	setSinglePointSymbolOutlineWidth(width: int): void;
	/**
	 * This applies to Single Point Tactical Graphics.
	 * @return
	 * @deprecated
	 */
	getSinglePointSymbolOutlineWidth(): int;
	setOutlineSPControlMeasures(value: boolean): void;
	getOutlineSPControlMeasures(): boolean;
	setActionPointDefaultFill(value: boolean): void;
	getActionPointDefaultFill(): boolean;
	/**
	 * false to use label font size
	 * true to scale it using symbolPixelBounds / 3.5
	 * @param value
	 */
	setScaleEchelon(value: boolean): void;
	/**
	 * Returns the value determining if we scale the echelon font size or
	 * just match the font size specified by the label font.
	 * @return true or false
	 */
	getScaleEchelon(): boolean;
	/**
	 * Determines how to draw the Affiliation modifier.
	 * True to draw as modifier label in the "E/F" location.
	 * False to draw at the top right corner of the symbol
	 */
	setDrawAffiliationModifierAsLabel(value: boolean): void;
	/**
	 * True to draw as modifier label in the "E/F" location.
	 * False to draw at the top right corner of the symbol
	 */
	getDrawAffiliationModifierAsLabel(): boolean;
	/**
	 * Sets the font to be used for modifier labels
	 * @param name Like "arial"
	 * @param weight Like "normal" or "bold"
	 * @param size Like 12
	 */
	setLabelFont(name: string, weight: string, size: int): void;
	/**
	 *
	 * @param name Like "arial"
	 * @param type Like Font.BOLD
	 * @param size Like 12
	 */
	setLabelFont(name: string, type: int, size: int): void;
	setMPLabelFont(name: string, weight: string, size: int): void;
	setMPLabelFont(name: string, weight: string, size: int, kmlScale: float): void;
	setMPLabelFont(name: string, type: int, size: int): void;
	setMPLabelFont(name: string, type: int, size: int, kmlScale: float): void;
	/**
	 * the font name to be used for modifier labels
	 * @return name of the label font
	 */
	getLabelFontName(): string;
	/**
	 * Like Font.BOLD
	 * @return type of the label font
	 */
	getLabelFontType(): int;
	/**
	 * get font point size
	 * @return size of the label font
	 */
	getLabelFontSize(): int;
	/**
	 * get font object used for labels
	 * @return Font object
	 */
	getLabelFont(): Font;
	/**
	 * get font object used for labels
	 * @return Font object
	 */
	getMPLabelFont(): Font;
	getKMLLabelScale(): float;
	/**
	 * the font name to be used for modifier labels
	 * @return name of the label font
	 */
	getMPLabelFontName(): string;
	/**
	 * Like Font.BOLD
	 * @return type of the label font
	 */
	getMPLabelFontType(): int;
	/**
	 * get font point size
	 * @return size of the label font
	 */
	getMPLabelFontSize(): int;
	/**
	 ** Get a boolean indicating between the use of ENY labels in all segments (false) or
	 * to only set 2 labels one at the north and the other one at the south of the graphic (true).
	 * @return {boolean}
	 */
	getTwoLabelOnly(): boolean;
	/**
	 * Set a boolean indicating between the use of ENY labels in all segments (false) or
	 * to only set 2 labels one at the north and the other one at the south of the graphic (true).
	 * @param TwoLabelOnly
	 */
	setTwoLabelOnly(TwoLabelOnly: boolean): void;
	/**
	 * When true, if the main icon is normally small to allow room for sector modifiers,
	 * make it larger when no sector modifiers are present for better visibility.
	 * @param scaleMainIcon
	 */
	setScaleMainIcon(scaleMainIcon: boolean): void;
	/**
	 * When true, if the main icon is normally small to allow room for sector modifiers,
	 * main icon is made larger when no sector modifiers are present for better visibility.
	 */
	getScaleMainIcon(): boolean;
	/**
	 * get the preferred fill affiliation color for units.
	 *
	 * @return Color like  Color(255, 255, 255)
	 *
	 * */
	getFriendlyUnitFillColor(): Color;
	/**
	 * Set the preferred fill affiliation color for units
	 *
	 * @param friendlyUnitFillColor Color like  Color(255, 255, 255)
	 *
	 * */
	setFriendlyUnitFillColor(friendlyUnitFillColor: Color): void;
	/**
	 * get the preferred fill affiliation color for units.
	 *
	 * @return Color like  Color(255, 255, 255)
	 *
	 * */
	getHostileUnitFillColor(): Color;
	/**
	 * Set the preferred fill affiliation color for units
	 *
	 * @param hostileUnitFillColor Color like  Color(255, 255, 255)
	 *
	 * */
	setHostileUnitFillColor(hostileUnitFillColor: Color): void;
	/**
	 * get the preferred fill affiliation color for units.
	 *
	 * @return Color like  Color(255, 255, 255)
	 *
	 * */
	getNeutralUnitFillColor(): Color;
	/**
	 * Set the preferred line affiliation color for units
	 *
	 * @param neutralUnitFillColor Color like  Color(255, 255, 255)
	 *
	 * */
	setNeutralUnitFillColor(neutralUnitFillColor: Color): void;
	/**
	 * get the preferred fill affiliation color for units.
	 *
	 * @return Color like  Color(255, 255, 255)
	 *
	 * */
	getUnknownUnitFillColor(): Color;
	/**
	 * Set the preferred fill affiliation color for units
	 *
	 * @param unknownUnitFillColor Color like  Color(255, 255, 255)
	 *
	 * */
	setUnknownUnitFillColor(unknownUnitFillColor: Color): void;
	/**
	 * get the preferred fill affiliation color for graphics.
	 *
	 * @return Color like  Color(255, 255, 255)
	 *
	 * */
	getHostileGraphicFillColor(): Color;
	/**
	 * Set the preferred fill affiliation color for graphics
	 *
	 * @param hostileGraphicFillColor Color like  Color(255, 255, 255)
	 *
	 * */
	setHostileGraphicFillColor(hostileGraphicFillColor: Color): void;
	/**
	 * get the preferred fill affiliation color for graphics.
	 *
	 * @return Color like  Color(255, 255, 255)
	 *
	 * */
	getFriendlyGraphicFillColor(): Color;
	/**
	 * Set the preferred fill affiliation color for graphics
	 *
	 * @param friendlyGraphicFillColor Color like  Color(255, 255, 255)
	 *
	 * */
	setFriendlyGraphicFillColor(friendlyGraphicFillColor: Color): void;
	/**
	 * get the preferred fill affiliation color for graphics.
	 *
	 * @return Color like  Color(255, 255, 255)
	 *
	 * */
	getNeutralGraphicFillColor(): Color;
	/**
	 * Set the preferred fill affiliation color for graphics
	 *
	 * @param neutralGraphicFillColor Color like  Color(255, 255, 255)
	 *
	 * */
	setNeutralGraphicFillColor(neutralGraphicFillColor: Color): void;
	/**
	 * get the preferred fill affiliation color for graphics.
	 *
	 * @return Color like  Color(255, 255, 255)
	 *
	 * */
	getUnknownGraphicFillColor(): Color;
	/**
	 * Set the preferred fill affiliation color for graphics
	 *
	 * @param unknownGraphicFillColor Color like  Color(255, 255, 255)
	 *
	 * */
	setUnknownGraphicFillColor(unknownGraphicFillColor: Color): void;
	/**
	 * get the preferred line affiliation color for units.
	 *
	 * @return Color like  Color(255, 255, 255)
	 *
	 * */
	getFriendlyUnitLineColor(): Color;
	/**
	 * Set the preferred line affiliation color for units
	 *
	 * @param friendlyUnitLineColor Color like  Color(255, 255, 255)
	 *
	 * */
	setFriendlyUnitLineColor(friendlyUnitLineColor: Color): void;
	/**
	 * get the preferred line   affiliation color for units.
	 *
	 * @return Color like  Color(255, 255, 255)
	 *
	 * */
	getHostileUnitLineColor(): Color;
	/**
	 * Set the preferred line affiliation color for units
	 *
	 * @param hostileUnitLineColor Color like  Color(255, 255, 255)
	 *
	 * */
	setHostileUnitLineColor(hostileUnitLineColor: Color): void;
	/**
	 * get the preferred line affiliation color for units.
	 *
	 * @return Color like  Color(255, 255, 255)
	 *
	 * */
	getNeutralUnitLineColor(): Color;
	/**
	 * Set the preferred line affiliation color for units
	 *
	 * @param neutralUnitLineColor Color like  Color(255, 255, 255)
	 *
	 * */
	setNeutralUnitLineColor(neutralUnitLineColor: Color): void;
	/**
	 * get the preferred line affiliation color for units.
	 *
	 * @return Color like  Color(255, 255, 255)
	 *
	 * */
	getUnknownUnitLineColor(): Color;
	/**
	 * Set the preferred line affiliation color for units
	 *
	 * @param unknownUnitLineColor Color like  Color(255, 255, 255)
	 *
	 * */
	setUnknownUnitLineColor(unknownUnitLineColor: Color): void;
	/**
	 * get the preferred line affiliation color for graphics.
	 *
	 * @return Color like  Color(255, 255, 255)
	 *
	 * */
	getFriendlyGraphicLineColor(): Color;
	/**
	 * Set the preferred line affiliation color for graphics
	 *
	 * @param friendlyGraphicLineColor Color like  Color(255, 255, 255)
	 *
	 * */
	setFriendlyGraphicLineColor(friendlyGraphicLineColor: Color): void;
	/**
	 * get the preferred line affiliation color for graphics.
	 *
	 * @return Color like  Color(255, 255, 255)
	 *
	 * */
	getHostileGraphicLineColor(): Color;
	/**
	 * Set the preferred line affiliation color for graphics
	 *
	 * @param hostileGraphicLineColor Color like  Color(255, 255, 255)
	 *
	 * */
	setHostileGraphicLineColor(hostileGraphicLineColor: Color): void;
	/**
	 * get the preferred line affiliation color for graphics.
	 *
	 * @return Color like  Color(255, 255, 255)
	 *
	 * */
	getNeutralGraphicLineColor(): Color;
	/**
	 * Set the preferred line affiliation color for graphics
	 *
	 * @param neutralGraphicLineColor Color like  Color(255, 255, 255)
	 *
	 * */
	setNeutralGraphicLineColor(neutralGraphicLineColor: Color): void;
	/**
	 * get the preferred line affiliation color for graphics.
	 *
	 * @return Color like  Color(255, 255, 255)
	 *
	 * */
	getUnknownGraphicLineColor(): Color;
	/**
	 * Set the preferred line affiliation color for graphics
	 *
	 * @param unknownGraphicLineColor Color like  Color(255, 255, 255)
	 *
	 * */
	setUnknownGraphicLineColor(unknownGraphicLineColor: Color): void;
	/**
	 * Set the preferred line and fill affiliation color for tactical graphics.
	 *
	 * @param friendlyGraphicLineColor Color
	 * @param hostileGraphicLineColor Color
	 * @param neutralGraphicLineColor Color
	 * @param unknownGraphicLineColor Color
	 * @param friendlyGraphicFillColor Color
	 * @param hostileGraphicFillColor Color
	 * @param neutralGraphicFillColor Color
	 * @param unknownGraphicFillColor Color
	 */
	setGraphicPreferredAffiliationColors(friendlyGraphicLineColor: Color, hostileGraphicLineColor: Color, neutralGraphicLineColor: Color, unknownGraphicLineColor: Color, friendlyGraphicFillColor: Color, hostileGraphicFillColor: Color, neutralGraphicFillColor: Color, unknownGraphicFillColor: Color): void;
	/**
	 * Set the preferred line and fill affiliation color for units and tactical graphics.
	 *
	 * @param friendlyUnitLineColor Color like  Color(255, 255, 255). Set to null to ignore setting
	 * @param hostileUnitLineColor Color
	 * @param neutralUnitLineColor Color
	 * @param unknownUnitLineColor Color
	 * @param friendlyUnitFillColor Color
	 * @param hostileUnitFillColor Color
	 * @param neutralUnitFillColor Color
	 * @param unknownUnitFillColor Color
	 */
	setUnitPreferredAffiliationColors(friendlyUnitLineColor: Color, hostileUnitLineColor: Color, neutralUnitLineColor: Color, unknownUnitLineColor: Color, friendlyUnitFillColor: Color, hostileUnitFillColor: Color, neutralUnitFillColor: Color, unknownUnitFillColor: Color): void;
}
/**
 * Utility class for helping to parse out parts of the symbol ID.
 *
 */
export declare class SymbolID {
	static readonly Version_2525D: number;
	static readonly Version_2525Dch1: number;
	/**
	 * @deprecated withdrawn from standard
	 */
	static readonly Version_APP6Dch2: number;
	static readonly Version_2525E: number;
	static readonly StandardIdentity_Context_Reality: number;
	static readonly StandardIdentity_Context_Exercise: number;
	static readonly StandardIdentity_Context_Simulation: number;
	static readonly StandardIdentity_Affiliation_Pending: number;
	static readonly StandardIdentity_Affiliation_Unknown: number;
	static readonly StandardIdentity_Affiliation_AssumedFriend: number;
	static readonly StandardIdentity_Affiliation_Friend: number;
	static readonly StandardIdentity_Affiliation_Neutral: number;
	static readonly StandardIdentity_Affiliation_Suspect_Joker: number;
	static readonly StandardIdentity_Affiliation_Hostile_Faker: number;
	static readonly SymbolSet_Unknown: number;
	static readonly SymbolSet_Air: number;
	static readonly SymbolSet_AirMissile: number;
	static readonly SymbolSet_Space: number;
	static readonly SymbolSet_SpaceMissile: number;
	static readonly SymbolSet_LandUnit: number;
	static readonly SymbolSet_LandCivilianUnit_Organization: number;
	static readonly SymbolSet_LandEquipment: number;
	static readonly SymbolSet_LandInstallation: number;
	static readonly SymbolSet_ControlMeasure: number;
	static readonly SymbolSet_DismountedIndividuals: number;
	static readonly SymbolSet_SeaSurface: number;
	static readonly SymbolSet_SeaSubsurface: number;
	static readonly SymbolSet_MineWarfare: number;
	static readonly SymbolSet_Activities: number;
	static readonly SymbolSet_Atmospheric: number;
	static readonly SymbolSet_Oceanographic: number;
	static readonly SymbolSet_MeteorologicalSpace: number;
	static readonly SymbolSet_SignalsIntelligence: number;
	static readonly SymbolSet_SignalsIntelligence_Space: number;
	static readonly SymbolSet_SignalsIntelligence_Air: number;
	static readonly SymbolSet_SignalsIntelligence_Land: number;
	static readonly SymbolSet_SignalsIntelligence_SeaSurface: number;
	static readonly SymbolSet_SignalsIntelligence_SeaSubsurface: number;
	static readonly SymbolSet_CyberSpace: number;
	static readonly SymbolSet_InvalidSymbol: number;
	static readonly SymbolSet_VersionExtensionFlag: number;
	static readonly Status_Present: number;
	static readonly Status_Planned_Anticipated_Suspect: number;
	static readonly Status_Present_FullyCapable: number;
	static readonly Status_Present_Damaged: number;
	static readonly Status_Present_Destroyed: number;
	static readonly Status_Present_FullToCapacity: number;
	static readonly Status_Present_VersionExtensionFlag: number;
	static readonly HQTFD_Unknown: number;
	static readonly HQTFD_FeintDummy: number;
	static readonly HQTFD_Headquarters: number;
	static readonly HQTFD_FeintDummy_Headquarters: number;
	static readonly HQTFD_TaskForce: number;
	static readonly HQTFD_FeintDummy_TaskForce: number;
	static readonly HQTFD_TaskForce_Headquarters: number;
	static readonly HQTFD_FeintDummy_TaskForce_Headquarters: number;
	static readonly HQTFD_VersionExtensionFlag: number;
	static readonly Echelon_Unknown: number;
	static readonly Echelon_Team_Crew: number;
	static readonly Echelon_Squad: number;
	static readonly Echelon_Section: number;
	static readonly Echelon_Platoon_Detachment: number;
	static readonly Echelon_Company_Battery_Troop: number;
	static readonly Echelon_Battalion_Squadron: number;
	static readonly Echelon_Regiment_Group: number;
	static readonly Echelon_Brigade: number;
	static readonly Echelon_VersionExtensionFlag: number;
	static readonly Echelon_Division: number;
	static readonly Echelon_Corps_MEF: number;
	static readonly Echelon_Army: number;
	static readonly Echelon_ArmyGroup_Front: number;
	static readonly Echelon_Region_Theater: number;
	static readonly Echelon_Region_Command: number;
	static readonly Echelon_VersionExtensionFlag2: number;
	static readonly Mobility_Unknown: number;
	static readonly Mobility_WheeledLimitedCrossCountry: number;
	static readonly Mobility_WheeledCrossCountry: number;
	static readonly Mobility_Tracked: number;
	static readonly Mobility_Wheeled_Tracked: number;
	static readonly Mobility_Towed: number;
	static readonly Mobility_Rail: number;
	static readonly Mobility_PackAnimals: number;
	static readonly Mobility_OverSnow: number;
	static readonly Mobility_Sled: number;
	static readonly Mobility_Barge: number;
	static readonly Mobility_Amphibious: number;
	static readonly Mobility_ShortTowedArray: number;
	static readonly Mobility_LongTowedArray: number;
	static readonly Leadership_Individual: number;
	static readonly FrameShape_Unknown: string;
	static readonly FrameShape_Space: string;
	static readonly FrameShape_Air: string;
	static readonly FrameShape_LandUnit: string;
	static readonly FrameShape_LandEquipment_SeaSurface: string;
	static readonly FrameShape_LandInstallation: string;
	static readonly FrameShape_DismountedIndividuals: string;
	static readonly FrameShape_SeaSubsurface: string;
	static readonly FrameShape_Activity_Event: string;
	static readonly FrameShape_Cyberspace: string;
	/**
	 * Attempts to resolve a bad symbol ID into a value that can be found in {@link MSLookup}.
	 * If it fails, it will return the symbol code for a invalid symbol which is displayed as
	 * an inverted question mark (110098000010000000000000000000)
	 * @param symbolID 30 character string
	 * @return 30 character string representing the resolved symbol ID.
	 * @deprecated See {@link SymbolUtilities.reconcileSymbolID()}
	 */
	static reconcileSymbolID(symbolID: string): string;
	/**
	 * Gets the version number from the Symbol ID at positions 1-2
	 * @param symbolID 30 character string
	 * @return number like {@link SymbolID.Version_2525Dch1} (11)
	 */
	static getVersion(symbolID: string): number;
	/**
	 * Sets the version number of the Symbol ID at positions 1-2
	 * @param symbolID 30 character string
	 * @param ver number like {@link SymbolID.Version_2525Dch1} (11)
	 * @return updated 30 character string symbol ID
	 */
	static setVersion(symbolID: string, ver: number): string;
	/**
	 * Gets the version number from the Symbol ID at positions 3-4.
	 * Restricted and No-Strike values are NATO only.
	 * @param symbolID 30 character string
	 * @return number, number will not be padded if it starts with a '0'
	 */
	static getStandardIdentity(symbolID: string): number;
	/**
	 * Sets the version number of the Symbol ID at positions 3-4
	 * @param symbolID 30 character string
	 * @param si number If number is a single digit, will pad with a '0' before inserting into symbol ID
	 * @return updated 30 character string symbol ID
	 */
	static setStandardIdentity(symbolID: string, si: number): string;
	/**
	 * Get Context (Reality (0), Exercise (1), Simulation (2)) at position 3
	 * Higher values are NATO only
	 * @param symbolID 30 Character string
	 * @return number
	 */
	static getContext(symbolID: string): number;
	/**
	 * Set Context (Reality (0), Exercise (1), Simulation (2)) at position 3
	 * @param symbolID 30 Character string
	 * @param context number
	 * @return string updated Symbol ID.
	 */
	static setContext(symbolID: string, context: number): string;
	/**
	 * Get Affiliation from position 4
	 * @param symbolID 30 Character string
	 * @return number like {@link SymbolID.StandardIdentity_Affiliation_Friend}
	 */
	static getAffiliation(symbolID: string): number;
	/**
	 * Set Affiliation at position 4
	 * @param symbolID 30 Character string
	 * @param affiliation like {@link SymbolID.StandardIdentity_Affiliation_Friend}
	 * @return string updated Symbol ID.
	 */
	static setAffiliation(symbolID: string, affiliation: number): string;
	/**
	 * Get Symbol Set from positions 5-6
	 * @param symbolID 30 Character string
	 * @return number like {@link SymbolID.SymbolSet_LandCivilianUnit_Organization}
	 */
	static getSymbolSet(symbolID: string): number;
	/**
	 * Set Symbol Set at positions 5-6
	 * @param symbolID 30 Character string
	 * @param ss like {@link SymbolID.SymbolSet_LandCivilianUnit_Organization}
	 * @return string updated Symbol ID.
	 */
	static setSymbolSet(symbolID: string, ss: number): string;
	/**
	 * Get Symbol Set from position 7
	 * @param symbolID 30 Character string
	 * @return number like {@link SymbolID.Status_Present}
	 */
	static getStatus(symbolID: string): number;
	/**
	 * Set Symbol Set at position 7
	 * @param symbolID 30 Character string
	 * @param status like {@link SymbolID.Status_Present}
	 * @return string updated Symbol ID.
	 */
	static setStatus(symbolID: string, status: number): string;
	/**
	 * Get Symbol Set from position 8
	 * @param symbolID 30 Character string
	 * @return number like {@link SymbolID.HQTFD_Headquarters}
	 */
	static getHQTFD(symbolID: string): number;
	/**
	 * Set Symbol Set at position 8
	 * @param symbolID 30 Character string
	 * @param HQTFD like {@link SymbolID.HQTFD_Headquarters}
	 * @return string updated Symbol ID.
	 */
	static setHQTFD(symbolID: string, HQTFD: number): string;
	/**
	 * Get Amplifier Descriptor which can describe things like
	 * Echelon / Mobility / Towed Array / Leadership Indicator from positions 9-10
	 * @param symbolID 30 Character string
	 * @return number
	 */
	static getAmplifierDescriptor(symbolID: string): number;
	/**
	 * Set Amplifier Descriptor which can describe things like
	 * Echelon / Mobility / Towed Array / Leadership Indicator at positions 9-10
	 * @param symbolID 30 Character string
	 * @param ad
	 * @return string
	 */
	static setAmplifierDescriptor(symbolID: string, ad: number): string;
	/**
	 * Get Entity Code from positions 11-16.
	 * These six digits identify a unique symbol within a symbol set.
	 * @param symbolID 30 Character string
	 * @return number
	 */
	static getEntityCode(symbolID: string): number;
	/**
	 * Set Entity Code at positions 11-16.
	 * These six digits identify a unique symbol within a symbol set.
	 * @param symbolID 30 Character string
	 * @param entityCode number
	 * @return string
	 */
	static setEntityCode(symbolID: string, entityCode: number): string;
	/**
	 * Get Entity from positions 11-12.
	 * @param symbolID 30 Character string
	 * @return number
	 */
	static getEntity(symbolID: string): number;
	/**
	 * Get Entity Type from positions 13-14.
	 * @param symbolID 30 Character string
	 * @return number
	 */
	static getEntityType(symbolID: string): number;
	/**
	 * Get Entity Subtype from positions 15-16.
	 * @param symbolID 30 Character string
	 * @return number
	 */
	static getEntitySubtype(symbolID: string): number;
	/**
	 * Get Sector 1 Modifier from positions 17-18.
	 * @param symbolID 30 Character string
	 * @return number
	 */
	static getModifier1(symbolID: string): number;
	/**
	 * Set Sector 1 Modifier at positions 17-18.
	 * @param symbolID 30 Character string
	 * @param mod1 number
	 * @return string
	 */
	static setModifier1(symbolID: string, mod1: number): string;
	/**
	 * Get Common Sector 1 Modifier from position 21.
	 * @param symbolID 30 Character string
	 * @return number
	 */
	static getCommonModifier1(symbolID: string): number;
	/**
	 * Set Common Sector 1 Modifier at position 21.
	 * @param symbolID 30 Character string
	 * @param mod1I number
	 * @return string
	 */
	static setCommonModifier1(symbolID: string, mod1I: number): string;
	/**
	 * Get Sector 2 Modifier from positions 17-18.
	 * @param symbolID 30 Character string
	 * @return number
	 */
	static getModifier2(symbolID: string): number;
	/**
	 * Set Sector 2 Modifier at positions 17-18.
	 * @param symbolID 30 Character string
	 * @param mod1 number
	 * @return string
	 */
	static setModifier2(symbolID: string, mod1: number): string;
	/**
	 * Get Common Sector 2 Modifier from position 22.
	 * @param symbolID 30 Character string
	 * @return number
	 */
	static getCommonModifier2(symbolID: string): number;
	/**
	 * Set Common Sector 2 Modifier at position 22.
	 * @param symbolID 30 Character string
	 * @param mod1I number
	 * @return string
	 */
	static setCommonModifier2(symbolID: string, mod1I: number): string;
	/**
	 * Returns true is symbol is of the Meteorological variety.
	 * @param symbolID 30 Character string
	 * @return boolean
	 * @deprecated See {@link SymbolUtilities.isWeather()}
	 */
	static isMETOC(symbolID: string): boolean;
	/**
	 * Build string to grab appropriate SVG file
	 * @param symbolID 30 Character string
	 * @return string
	 * @deprecated See {@link SVGLookup.getFrameID()}
	 */
	static getFrameID(symbolID: string): string;
	/**
	 * Build string to grab appropriate SVG file
	 * @param symbolID 30 Character string
	 * @return string
	 * @deprecated See {@link SVGLookup.getMainIconID()}
	 */
	static getMainIconID(symbolID: string): string;
	/**
	 * Build string to grab appropriate SVG file
	 * @param symbolID 30 Character string
	 * @return string
	 * @deprecated See {@link SVGLookup.getMod2ID()} (String)}
	 */
	static getMod2ID(symbolID: string): string;
	/**
	 * Build string to grab appropriate SVG file
	 * @param symbolID 30 Character string
	 * @return string
	 * @deprecated See {@link SVGLookup.getMod1ID()} (String)}
	 */
	static getMod1ID(symbolID: string): string;
	/**
	 * Gets the 3 digit county code from positions 28-30
	 * @param symbolID 30 Character string
	 * @return number
	 */
	static getCountryCode(symbolID: string): number;
	/**
	 * In 2525E, position 23 of the symbol code has the Frame Shape modifier.
	 * This lets a user force a different frame shape than what a symbol would normally have.
	 * Like you could have Air Fixed Wing with a ground unit rectangle frame for when it's on the ground.
	 * This function returns the frame shape value for what the default frame would be for a specific symbol set.
	 * @param symbolID 30 Character string
	 * @return string (1 character)
	 */
	static getDefaultFrameShape(symbolID: string): string;
	/**
	 * Gets the Frame Shape override from position 23.
	 * @param symbolID 30 Character string
	 * @return string (1 character)
	 */
	static getFrameShape(symbolID: string): string;
}
declare class AffineTransform {
	constructor();
}
declare class PathIterator {
	static readonly SEG_CLOSE: int;
	static readonly SEG_CUBICTO: int;
	static readonly SEG_LINETO: int;
	static readonly SEG_MOVETO: int;
	static readonly SEG_QUADTO: int;
	static readonly WIND_EVEN_ODD: int;
	static readonly WIND_NON_ZERO: int;
	private _currentSeg;
	private _pts;
	constructor(tx: AffineTransform | null);
	getPoints(): Array<POINT2>;
	currentSegment(coords: number[]): int;
	getWindingRule(): int;
	isDone(): boolean;
	next(): void;
	reset(): void;
	moveTo(x: double, y: double): void;
	lineTo(x: double, y: double): void;
	cubicTo(x1: double, y1: double, x2: double, y2: double, x3: double, y3: double): void;
	curveTo(x1: double, y1: double, x2: double, y2: double, x3: double, y3: double): void;
	quadTo(x1: double, y1: double, x2: double, y2: double): void;
	getBounds(): Rectangle2D;
	setPathIterator(pts: Array<POINT2>): void;
}
/**
 *
 *
 */
export interface Shape {
	contains(x: int, y: int): boolean;
	contains(x: int, y: int, width: int, height: int): boolean;
	contains(pt: Point2D): boolean;
	getBounds2D(): Rectangle2D;
	getBounds(): Rectangle;
	intersects(x: double, y: double, w: double, h: double): boolean;
	intersects(rect: Rectangle2D): boolean;
	getPathIterator(at: AffineTransform | null): PathIterator;
}
declare class Rectangle implements Shape {
	static readonly OUT_LEFT = 1;
	static readonly OUT_TOP = 2;
	static readonly OUT_RIGHT = 4;
	static readonly OUT_BOTTOM = 8;
	x: int;
	y: int;
	width: int;
	height: int;
	constructor();
	constructor(x1: int, y1: int, width1: int, height1: int);
	getShapeType(): string;
	getBounds(): Rectangle;
	getPathIterator(at: AffineTransform): null;
	intersects(rect: Rectangle2D): boolean;
	intersects(x1: double, y1: double, width1: double, height1: double): boolean;
	contains(pt: Point2D): boolean;
	contains(x1: int, y1: int): boolean;
	contains(x1: int, y1: int, width1: int, height1: int): boolean;
	getBounds2D(): Rectangle2D;
	getX(): double;
	getY(): int;
	getMinX(): int;
	getMinY(): int;
	getMaxX(): int;
	getMaxY(): int;
	getHeight(): int;
	getWidth(): int;
	getBottom(): number;
	getRight(): number;
	getCenterX(): number;
	/**
	 *
	 * @returns {Number}
	 */
	getCenterY(): number;
	grow(h: int, v: int): void;
	setRect(rect: Rectangle): void;
	/**
 * setLocation x,y (top,left) while maintaining the width and height.
 * @param x
 * @param y
 */
	setLocation(x: number, y: number): void;
	isEmpty(): boolean;
	shift(x: number, y: number): void;
	/**
	 * moves top,left points leaving bottom,right intact.
	 * adjusts the height & width values as necessary
	 * @param x
	 * @param y
	 */
	shiftTL(x: number, y: number): void;
	/**
	 * moves bottom,right points leaving top,left intact.
	 * adjusts the height & width values as necessary
	 * @param {type} x the amount to move the right point by
	 * @param {type} y the amount to move the bottom point by
	 * @returns {_L7.Anonym$0.Rectangle.shiftTL}
	 */
	shiftBR(x: number, y: number): void;
	/**
 * Will merge the bounds of two rectangle.
 * @param rect
 */
	union(rect: Rectangle): void;
	unionPoint(point: Point): void;
	/**
*
* @param point
* @returns
*/
	containsPoint(point: Point): boolean;
	containsRectangle(rect: Rectangle): boolean;
	/**
 * Ported from Java
 */
	private outcode;
	/**
	* Tests if the specified line segment intersects the interior of this
	* <code>Rectangle</code>. Ported from java.
	*
	* @param x1 the X coordinate of the start point of the specified
	*           line segment
	* @param y1 the Y coordinate of the start point of the specified
	*           line segment
	* @param x2 the X coordinate of the end point of the specified
	*           line segment
	* @param y2 the Y coordinate of the end point of the specified
	*           line segment
	* @return <code>true</code> if the specified line segment intersects
	* the interior of this <code>Rectangle</code>; <code>false</code>
	* otherwise.
	*/
	intersectsLine(x1: number, y1: number, x2: number, y2: number): boolean;
	setPath(context: OffscreenCanvasRenderingContext2D): void;
	stroke(context: OffscreenCanvasRenderingContext2D): void;
	fill(context: OffscreenCanvasRenderingContext2D): void;
	clone(): Rectangle;
	/**
	 * ported from java
	 */
	/**
	 *
	 * @param stroke named color or value of rgb(#,#,#)
	 * @param strokeWidth width of line in # of pixels
	 * @param fill named color or value of rgb(#,#,#)
	 * @returns
	 */
	toSVGElement(stroke: string | null, strokeWidth: number, fill: string | null): string;
}
declare class Polygon {
	/**
	 * The points buffer capacity
	 */
	private static BUFFER_CAPACITY;
	npoints: int;
	xpoints: int[];
	ypoints: int[];
	protected bounds: Rectangle;
	constructor();
	/**
	 *
	 * @param xpoints
	 * @param ypoints
	 * @param npoints
	 */
	constructor(xpoints: int[], ypoints: int[], npoints: int);
	private copyOf;
	reset(): void;
	invalidate(): void;
	addPoint(px: int, py: int): void;
	getBounds(): Rectangle;
	getBoundingBox(): Rectangle;
	contains(p: Point | Point2D): boolean;
	contains(r: Rectangle2D): boolean;
	contains(x: double, y: double): boolean;
	contains(x: double, y: double, w: double, h: double): boolean;
	getBounds2D(): null;
	intersects(r: Rectangle2D): boolean;
	intersects(x: double, y: double, w: double, h: double): boolean;
	getPathIterator(at: AffineTransform | null): PathIterator;
	getPathIterator(at: AffineTransform, flatness: double): PathIterator;
}
/**
 *
 *
 */
export interface Stroke {
	createStrokedShape(s: Shape): Shape;
}
declare class BasicStroke implements Stroke {
	/**
	 * Joins path segments by extending their outside edges until they meet.
	 */
	static readonly JOIN_MITER: int;
	/**
	 * Joins path segments by rounding off the corner at a radius of half the
	 * line width.
	 */
	static readonly JOIN_ROUND: int;
	/**
	 * Joins path segments by connecting the outer corners of their wide
	 * outlines with a straight segment.
	 */
	static readonly JOIN_BEVEL: int;
	/**
	 * Ends unclosed subpaths and dash segments with no added decoration.
	 */
	static readonly CAP_BUTT: int;
	/**
	 * Ends unclosed subpaths and dash segments with a round decoration that has
	 * a radius equal to half of the width of the pen.
	 */
	static readonly CAP_ROUND: int;
	/**
	 * Ends unclosed subpaths and dash segments with a square projection that
	 * extends beyond the end of the segment to a distance equal to half of the
	 * line width.
	 */
	static readonly CAP_SQUARE: int;
	protected width: float;
	protected join: int;
	protected cap: int;
	protected miterlimit: float;
	protected dash: float[] | null;
	protected dash_phase: float;
	/**
	 * Constructs a new <code>BasicStroke</code> with defaults for all
	 * attributes. The default attributes are a solid line of width 1.0,
	 * CAP_SQUARE, JOIN_MITER, a miter limit of 10.0.
	 */
	constructor();
	/**
	 * Constructs a solid <code>BasicStroke</code> with the specified line width
	 * and with default values for the cap and join styles.
	 *
	 * @param width
	 * the width of the <code>BasicStroke</code>
	 * @throws IllegalArgumentException
	 * if <code>width</code> is negative
	 */
	constructor(width: float);
	constructor(width: float, cap: int, join: int);
	constructor(width: float, cap: int, join: int, miterlimit: float);
	constructor(width: float, cap: int, join: int, miterlimit: float, dash: float[] | null, dash_phase: float);
	/**
	 * Returns a <code>Shape</code> whose interior defines the stroked outline
	 * of a specified <code>Shape</code>.
	 *
	 * @param s
	 * the <code>Shape</code> boundary be stroked
	 * @return the <code>Shape</code> of the stroked outline.
	 */
	createStrokedShape(poly: Polygon): Shape;
	getLineWidth(): float;
	/**
	 * Returns the end cap style.
	 *
	 * @return the end cap style of this <code>BasicStroke</code> as one of the
	 * static <code>int</code> values that define possible end cap
	 * styles.
	 */
	getEndCap(): int;
	getLineJoin(): int;
	/**
	 * Returns the limit of miter joins.
	 *
	 * @return the limit of miter joins of the <code>BasicStroke</code>.
	 */
	getMiterLimit(): float;
	/**
	 * Returns the array representing the lengths of the dash segments.
	 * Alternate entries in the array represent the user space lengths of the
	 * opaque and transparent segments of the dashes. As the pen moves along the
	 * outline of the <code>Shape</code> to be stroked, the user space distance
	 * that the pen travels is accumulated. The distance value is used to index
	 * into the dash array. The pen is opaque when its current cumulative
	 * distance maps to an even element of the dash array and transparent
	 * otherwise.
	 *
	 * @return the dash array.
	 */
	getDashArray(): number[] | null;
	getDashPhase(): float;
	/**
	 * Returns the hashcode for this stroke.
	 *
	 * @return a hash code for this stroke.
	 */
	hashCode(): int;
	static GetInteriorPoints(pLinePoints: POINT2[], vblCounter: int, lineType: int, dist: double): Array<POINT2>;
}
declare class FontRenderContext {
	constructor();
}
declare class TextLayout {
	protected _font: Font;
	protected _str: string;
	constructor(s: string, font: Font, frc: FontRenderContext);
	getOutline(tx: AffineTransform | null): Shape;
	getPixelBounds(frc: FontRenderContext, x: float, y: float): null;
	getBounds(): Rectangle;
}
declare class TexturePaint {
	private _rect;
	private _g2d;
	private _bi;
	constructor(bi: ImageBitmap, rect: Rectangle2D | null);
}
/**
 * Holds information on how to draw the pieces of a multipoint symbol.
 * Can be retrieved from {@link MilStdSymbol#getSymbolShapes()} and
 * {@link MilStdSymbol#getModifierShapes()} after {@link armyc2.c5isr.web.render.WebRenderer#RenderMultiPointAsMilStdSymbol(String, String, String, String, String, String, double, String, Map, Map)} is called.
 */
export declare class ShapeInfo {
	static SHAPE_TYPE_POLYLINE: int;
	static SHAPE_TYPE_FILL: int;
	static SHAPE_TYPE_MODIFIER: int;
	static SHAPE_TYPE_MODIFIER_FILL: int;
	static SHAPE_TYPE_UNIT_FRAME: int;
	static SHAPE_TYPE_UNIT_FILL: int;
	static SHAPE_TYPE_UNIT_SYMBOL1: int;
	static SHAPE_TYPE_UNIT_SYMBOL2: int;
	static SHAPE_TYPE_UNIT_DISPLAY_MODIFIER: int;
	static SHAPE_TYPE_UNIT_ECHELON: int;
	static SHAPE_TYPE_UNIT_AFFILIATION_MODIFIER: int;
	static SHAPE_TYPE_UNIT_HQ_STAFF: int;
	static SHAPE_TYPE_TG_SP_FILL: int;
	static SHAPE_TYPE_TG_SP_FRAME: int;
	static SHAPE_TYPE_TG_Q_MODIFIER: int;
	static SHAPE_TYPE_TG_SP_OUTLINE: int;
	static SHAPE_TYPE_SINGLE_POINT_OUTLINE: int;
	static SHAPE_TYPE_UNIT_OUTLINE: int;
	static SHAPE_TYPE_UNIT_OPERATIONAL_CONDITION: int;
	static justify_left: int;
	static justify_center: int;
	static justify_right: int;
	protected _Shape: Shape;
	private stroke;
	private gp;
	private fillStyle;
	/**
	 * @deprecated
	 */
	private texturePaint;
	private _ShapeType;
	private lineColor;
	private fillColor;
	private textBackgoundColor;
	private _TextLayout;
	private _Position;
	private _ModifierString;
	private _ModifierPosition;
	private _ModifierImageInfo;
	private _ModifierAngle;
	private _Tag;
	/**
	 * @deprecated
	 */
	private _shader;
	private _patternFillInfo;
	private _justify;
	private _Polylines;
	constructor();
	constructor(shape: Shape);
	constructor(textLayout: TextLayout, position: Point2D);
	/**
	 *
	 * @param shape
	 * @param shapeType
	 * ShapeInfo.SHAPE_TYPE_
	 */
	constructor(shape: Shape, shapeType: int);
	getShape(): Shape;
	setShape(value: Shape): void;
	getTextLayout(): TextLayout;
	setTextLayout(value: TextLayout): void;
	setModifierString(value: string): void;
	getModifierString(): string;
	setModifierPosition(value: Point2D): void;
	getModifierPosition(): Point2D;
	setModifierAngle(value: double): void;
	getModifierAngle(): double;
	/**
	 *
	 * @deprecated use {@link setModifierPosition()}
	 */
	setModifierStringPosition(value: Point2D): void;
	/**
	 *
	 * @deprecated use {@link getModifierPosition()}
	 */
	getModifierStringPosition(): Point2D;
	/**
	 *
	 * @deprecated use {@link setModifierAngle()}
	 */
	setModifierStringAngle(value: double): void;
	/**
	 *
	 * @deprecated use {@link getModifierAngle()}
	 */
	getModifierStringAngle(): double;
	setModifierImage(value: SVGSymbolInfo): void;
	getModifierImage(): string;
	getModifierImageInfo(): SVGSymbolInfo;
	/**
	 * Object that can be used to store anything.
	 * Will not be looked at when rendering.
	 * Null by default
	 * @param value
	 */
	setTag(value: any): void;
	/**
	 * Object that can be used to store anything.
	 * Will not be looked at when rendering.
	 * Null by default
	 * @return
	 */
	getTag(): any;
	/**
	 * Gets bounds for the shapes.  Incorporates AffineTransform if not null
	 * in the ShapeInfo object.
	 * @return
	 */
	getBounds(): Rectangle | null;
	/**
	 * needed to draw Glyphs and TextLayouts
	 * @param position
	 */
	setGlyphPosition(position: Point | Point2D): void;
	/**
	 * needed to draw Glyphs and TextLayouts
	 * @return
	 */
	getGlyphPosition(): Point2D;
	setLineColor(value: Color | null): void;
	getLineColor(): Color;
	setFillColor(value: Color | null): void;
	getFillColor(): Color | null;
	setTextBackgroundColor(value: Color): void;
	getTextBackgroundColor(): Color;
	getStroke(): BasicStroke;
	/**
	 * @deprecated
	 */
	getTexturePaint(): TexturePaint | null;
	/**
	 * @deprecated
	 */
	setTexturePaint(value: TexturePaint | null): void;
	getFillStyle(): int;
	setFillStyle(value: int): void;
	setStroke(s: BasicStroke): void;
	/**
	 * For Internal Renderer use
	 * @param value
	 * ShapeInfo.SHAPE_TYPE_
	 *
	 */
	setShapeType(value: int): void;
	/**
	 * For Internal Renderer use
	 * @return ShapeInfo.SHAPE_TYPE_
	 *
	 */
	getShapeType(): int;
	getPolylines(): Array<Array<Point2D>>;
	setPolylines(value: Array<Array<Point2D>>): void;
	/**
	 * @deprecated
	 */
	setShader(value: ImageBitmap): void;
	/**
	 * @deprecated
	 */
	getShader(): ImageBitmap;
	setPatternFillImage(img: SVGSymbolInfo): void;
	getPatternFillImage(): string;
	getPatternFillImageInfo(): SVGSymbolInfo;
	getTextJustify(): int;
	setTextJustify(value: int): void;
}
declare class DistanceUnit {
	private static readonly FEET_PER_METER;
	private static readonly FLIGHT_LEVEL_PER_METER;
	readonly conversionFactor: double;
	readonly label: string;
	constructor(conversionFactor: double, label: string);
	static parse(distanceUnitText: string): DistanceUnit | null;
	toAttribute(): string;
	static METERS: DistanceUnit;
	static FEET: DistanceUnit;
	static FLIGHT_LEVEL: DistanceUnit;
}
/**
 * Object that holds information on how to draw a multipoint symbol after {@link armyc2.c5isr.web.render.WebRenderer#RenderMultiPointAsMilStdSymbol(String, String, String, String, String, String, double, String, Map, Map)}  is called.
 */
export declare class MilStdSymbol {
	/**
	 * modifiers
	 */
	private _Properties;
	private _X_Altitude;
	private _AM_Distance;
	private _AN_Azimuth;
	private _symbolID;
	/**
	 * unique ID for this symbol, for client use
	 */
	private _UUID;
	private _SymbolShapes;
	/**
	 * collection of shapes for the modifiers
	 */
	private _ModifierShapes;
	private _Coordinates;
	private _UnitSize;
	private _scale;
	private _KeepUnitRatio;
	protected _LineWidth: number;
	protected _LineColor: Color;
	protected _FillColor: Color;
	protected _TextColor: Color;
	protected _TextBackgroundColor: Color;
	protected _Rotation: double;
	protected _Outline: boolean;
	protected _OutLineColor: Color;
	protected _OutLineWidth: int;
	protected _tp: TexturePaint;
	protected _fs: boolean;
	protected _patternFillType: int;
	private static _AltitudeMode;
	private static _AltitudeUnit;
	private static _DistanceUnit;
	private static _useDashArray;
	private static _hideOptionalLabels;
	private static _DrawAffiliationModifierAsLabel;
	private static _UseLineInterpolation;
	protected _Tag: any;
	/**
	 *
	 * @param symbolID code, 20-30 digits long that represents the symbol
	 * @param uniqueID for the client's use
	 * @param modifiers use keys from Modifiers.
	 * @param Coordinates {@link ArrayList} of {@link Point2D} coordinates for the symbol
	 * @param keepUnitRatio - default TRUE
	 * modifiers
	 */
	constructor(symbolID: string, uniqueID: string, Coordinates: Array<Point2D>, modifiers: Map<string, string>, keepUnitRatio?: boolean);
	getFillStyle(): TexturePaint;
	setFillStyle(value: TexturePaint): void;
	getUseFillPattern(): boolean;
	setUseFillPattern(value: boolean): void;
	/**
	 * @deprecated
	 */
	getPatternFillType(): int;
	/**
	 * 0=Solid, 2=ForwardHatch, 3=BackwardHatch, 4=verticalHatch, 5=horizonalHatch, 8=CrossHatch
	 * Only affects Basic Shapes.  Will not apply to MilStd Symbology so as to not confuse some
	 * symbols with others.
	 * @param value {@link Integer}
	 *
	 * @deprecated
	 */
	setPatternFillType(value: int): void;
	getAltitudeMode(): string;
	setAltitudeMode(value: string): void;
	getAltitudeUnit(): DistanceUnit;
	setAltitudeUnit(unit: DistanceUnit): void;
	getDistanceUnit(): DistanceUnit;
	setDistanceUnit(unit: DistanceUnit): void;
	getUseDashArray(): boolean;
	setUseDashArray(value: boolean): void;
	getHideOptionalLabels(): boolean;
	setHideOptionalLabels(value: boolean): void;
	setUseLineInterpolation(value: boolean): void;
	getUseLineInterpolation(): boolean;
	setUnitSize(pixelSize: int): void;
	getUnitSize(): int;
	setKeepUnitRatio(value: boolean): void;
	getKeepUnitRatio(): boolean;
	/**
	 * Determines how to draw the Affiliation Modifier. True to draw as modifier
	 * label in the "E/F" location. False to draw at the top right corner of the
	 * symbol
	 * @param value {@link Boolean}
	 *
	 * @deprecated
	 */
	setDrawAffiliationModifierAsLabel(value: boolean): void;
	/**
	 * True to draw as modifier label in the "E/F" location. False to draw at
	 * the top right corner of the symbol
	 * @return {@link Boolean}
	 *
	 * @deprecated
	 */
	getDrawAffiliationModifierAsLabel(): boolean;
	/**
	 * Returns the modifier map for the symbol
	 * @return {@link Map}
	 */
	getModifierMap(): Map<string, string>;
	/**
	 * sets the modifier map for the symbol
	 * @param modifiers {@link Map}
	 */
	setModifierMap(modifiers: Map<string, string>): void;
	/**
	 * Get a modifier value
	 * @param modifier {@link Modifiers}
	 * @return {@link String}
	 */
	getModifier(modifier: string): string;
	/**
	 * Gets modifier value based on modifier constant and index in array
	 * @param modifier {@link Modifiers}
	 * @param index {@link Integer} array location, only applicable to AM, AN and X
	 * @return {@link String}
	 */
	getModifier(modifier: string, index: int): string;
	/**
	 * Set a modifier value
	 * @param modifier {@link Modifiers}
	 * @param value {@link String}
	 */
	setModifier(modifier: string, value: string): void;
	/**
	 * Modifiers must be added in order. No setting index 2 without first
	 * setting index 0 and 1. If setting out of order is attempted, the value
	 * will just be added to the end of the list.
	 *
	 * @param modifier {@link Modifiers}
	 * @param value {@link String}
	 * @param index {@link Integer}
	 */
	setModifier(modifier: string, value: string, index: int): void;
	/**
	 * Get modifier value for AM, AN or X
	 * @param modifier {@link Modifiers}
	 * @param index {@link Integer} array location
	 * @return {@link Double}
	 */
	getModifier_AM_AN_X(modifier: string, index: int): string | null;
	setModifier_AM_AN_X(modifier: string, value: number, index: int): void;
	getModifiers_AM_AN_X(modifier: string): Array<number> | null;
	setModifiers_AM_AN_X(modifier: string, modifiers: Array<number>): void;
	/**
	 *
	 * @param value {@link Color}
	 */
	setFillColor(value: Color): void;
	/**
	 *
	 * @return {@link Color}
	 */
	getFillColor(): Color;
	/**
	*
	* @param value {@link Color}
	*/
	setTextColor(value: Color): void;
	/**
	 *
	 * @return {@link Color}
	 */
	getTextColor(): Color;
	/**
	*
	* @param value {@link Color}
	*/
	setTextBackgroundColor(value: Color): void;
	/**
	 *
	 * @return {@link Color}
	 */
	getTextBackgroundColor(): Color;
	/**
	 *
	 * @param value {@link Integer}
	 */
	setLineWidth(value: int): void;
	/**
	 *
	 * @return {@link Integer}
	 */
	getLineWidth(): int;
	/**
	 * If value is null or SymbolUtilities.isGreenProtectionGraphic() is true then value is ignored
	 *
	 * @param value {@link Color}
	 */
	setLineColor(value: Color | null): void;
	/**
	 *
	 * @return {@link Color}
	 */
	getLineColor(): Color;
	/**
	 * if null, renderer will use white or black for the outline based on the color
	 * of the symbol. Otherwise, it will used the passed color value.
	 *
	 * @param value {@link Color}
	 */
	setOutlineColor(value: Color): void;
	getOutlineColor(): Color;
	/**
	 * Extra value for client. defaults to null. Not used for rendering by
	 * JavaRenderer
	 *
	 * @param value  {@link Object}
	 * @deprecated
	 */
	setTag(value: any): void;
	/**
	 * Extra value for client. defaults to null. Not used for rendering by
	 * JavaRenderer
	 *
	 * @return {@link Object}
	 * @deprecated
	 */
	getTag(): any;
	/**
	 *
	 * @param value {@link ArrayList}
	 */
	setCoordinates(value: Array<Point2D>): void;
	/**
	 *
	 * @return {@link ArrayList}
	 */
	getCoordinates(): Array<Point2D>;
	/**
	 * Shapes that represent the symbol modifiers
	 *
	 * @param value ArrayList&lt;Shape&gt;
	 */
	setModifierShapes(value: Array<ShapeInfo>): void;
	/**
	 * Shapes that represent the symbol modifiers
	 *
	 * @return {@link ArrayList}
	 */
	getModifierShapes(): Array<ShapeInfo>;
	/**
	 * the java shapes that make up the symbol
	 *
	 * @param value ArrayList&lt;ShapeInfo&gt;
	 */
	setSymbolShapes(value: Array<ShapeInfo>): void;
	/**
	 * the java shapes that make up the symbol
	 *
	 * @return {@link ArrayList}
	 */
	getSymbolShapes(): Array<ShapeInfo>;
	/**
	 * The Symbol Id of the MilStdSymbol.
	 *
	 * @return {@link String}
	 */
	getSymbolID(): string;
	/**
	 * Unique ID of the Symbol. For client use.
	 *
	 * @return {@link String}
	 */
	getUUID(): string;
	/**
	 * Unique ID of the Symbol. For client use.
	 *
	 * @param ID {@link String}
	 */
	setUUID(ID: string): void;
	/**
	 * Sets the Symbol ID for the symbol. Should be a 20-30 digit string from
	 * the milstd.
	 *
	 * @param value {@link String}
	 */
	setSymbolID(value: string): void;
	private _wasClipped;
	set_WasClipped(value: boolean): void;
	get_WasClipped(): boolean;
}
/**
 * Interface for Point Conversion objects.  Recommend using the functions
 * that take and return Point2D objects.
 *
 */
export interface IPointConversion {
	PixelsToGeo(pixel: Point2D): Point2D;
	GeoToPixels(coord: Point2D): Point2D;
}
/**
 *
 *
 */
export declare class PointConverter3D implements IPointConversion {
	private _controlLat;
	private _controlLong;
	private _scale;
	private _metersPerPixel;
	constructor(controlLong: double, controlLat: double, scale: double);
	PixelsToGeo(pixel: Point): Point2D;
	PixelsToGeo(pixel: Point2D): Point2D;
	GeoToPixels(coord: Point2D): Point;
	GeoToPixels(coord: Point2D): Point2D;
}
declare class FontMetrics {
	protected _fontRenderContext: FontRenderContext;
	protected _font: Font;
	constructor(font: Font);
	stringWidth(str: string): int;
	getFontRenderContext(): FontRenderContext;
}
declare class Graphics2D {
	private _font;
	private _fontMetrics;
	private _fontRenderContext;
	constructor();
	setFont(value: Font): void;
	getFont(): Font;
	setFontMetrics(value: FontMetrics): void;
	getFontMetrics(): FontMetrics;
	setColor(color: Color): void;
	setBackground(color: Color): void;
	setTransform(id: AffineTransform): void;
	getTransform(): null;
	setStroke(stroke: BasicStroke): void;
	drawLine(x1: double, y1: double, x2: double, y2: double): void;
	dispose(): void;
	rotate(theta: double, x: double, y: double): void;
	clearRect(x: double, y: double, width: double, height: double): void;
	drawString(s: string, x: double, y: double): void;
	getFontRenderContext(): FontRenderContext;
}
declare class Shape2 extends ShapeInfo {
	constructor(value: int);
	private style;
	set_Style(value: int): void;
	get_Style(): int;
	lineTo(pt: POINT2): void;
	moveTo(pt: POINT2): void;
	getBounds(): Rectangle;
	getPoints(): Array<POINT2>;
}
declare class Modifier2 {
	private textPath;
	private textID;
	private featureID;
	private text;
	private image;
	private iteration;
	private justify;
	private type;
	private lineFactor;
	private static readonly _className;
	private isIntegral;
	private fitsMBR;
	protected constructor();
	private static readonly toEnd;
	private static readonly aboveMiddle;
	private static readonly area;
	private static readonly screen;
	private static readonly aboveEnd;
	private static readonly aboveMiddlePerpendicular;
	private static readonly aboveStartInside;
	private static readonly aboveEndInside;
	private static readonly areaImage;
	private static fillAlphaCanObscureText;
	private static DoublesBack;
	/**
	 * Returns a generic label for the symbol per Mil-Std-2525
	 *
	 * @param tg
	 * @return
	 */
	private static GetCenterLabel;
	get_TextPath(): POINT2[];
	protected set_TextPath(value: POINT2[]): void;
	protected set_IsIntegral(value: boolean): void;
	protected get_IsIntegral(): boolean;
	private static AddOffsetModifier;
	/**
	 *
	 * @param tg
	 * @param text
	 * @param type
	 * @param lineFactor
	 * @param ptStart
	 * @param ptEnd
	 */
	private static AddModifier;
	private static AddModifier2;
	private static AddIntegralModifier;
	/**
	 * sets modifier.textId to the modifier type, e.g. label, T, T1, etc.
	 *
	 * @param tg
	 * @param text
	 * @param type
	 * @param lineFactor
	 * @param pt0
	 * @param pt1
	 * @param modifierType
	 */
	private static AddAreaModifier;
	private static AddIntegralAreaModifier;
	private static AddImageModifier;
	/**
	 * Returns symbol MBR. Assumes points have been initialized with value of
	 * 0th point
	 *
	 * @param tg the tactical graphic object
	 * @param ptUl OUT - MBR upper left
	 * @param ptUr OUT - MBR upper right
	 * @param ptLr OUT - MBR lower right
	 * @param ptLl OUT - MBR lower left
	 */
	static GetMBR(tg: TGLight, ptUl: POINT2, ptUr: POINT2, ptLr: POINT2, ptLl: POINT2): void;
	/**
	 * Tests segment of a Boundary
	 *
	 * @param tg
	 * @param g2d
	 * @param middleSegment
	 * @return
	 */
	private static GetBoundarySegmentTooShort;
	/**
	 * Handles the line breaks for Boundary and Engineer Work Line
	 *
	 * @param tg
	 * @param g2d
	 */
	private static AddBoundaryModifiers;
	/**
	 * added for USAS
	 *
	 * @param tg
	 * @param metrics
	 * @deprecated
	 */
	private static AddNameAboveDTG;
	/**
	 * shifts the path for modifiers that use toEnd to prevent vertical paths
	 *
	 * @param tg
	 * @param pt0
	 * @param pt1
	 * @param ptLast
	 * @param ptNextToLast
	 */
	private static shiftModifierPath;
	/**
	 * Adds label on line
	 *
	 * Replaces areasWithENY()
	 *
	 * @param label
	 * @param tg
	 * @param g2d
	 * @param twoLabelOnly - true if only add two instances of label to line (used with N modifier)
	 *                     Ignored if RendererSettings.TwoLabelOnly is true
	 */
	private static addModifierOnLine;
	/**
	 * Adds N modifier on line
	 */
	private static addNModifier;
	private static addModifierBottomSegment;
	private static addModifierTopSegment;
	private static addDTG;
	private static getVisibleMiddleSegment;
	/**
	 * called repeatedly by RemoveModifiers to remove modifiers which fall
	 * outside the symbol MBR
	 *
	 * @param tg
	 * @param modifierType
	 */
	private static removeModifier;
	/**
	 * removes text modifiers for CPOF tactical areas which do not fit inside
	 * the symbol MBR
	 *
	 * @param tg
	 * @param g2d
	 * @param isTextFlipped true if text is flipped from the last segment
	 * orientation
	 * @param iteration the instance count for this modifier
	 */
	static RemoveModifiers(tg: TGLight, g2d: Graphics2D, isTextFlipped: boolean, iteration: int): void;
	/**
	 * Calculates a segment in the pixels middle by length to hold a string.
	 *
	 * @param tg
	 * @param stringWidth
	 * @param segPt0
	 * @param segPt1
	 */
	private static getPixelsMiddleSegment;
	private static getChange1Height;
	/**
	 * scale the line factor for closed areas
	 *
	 * @param tg
	 */
	private static scaleModifiers;
	/**
	 * Calculate modifiers identical to addModifiers except use geodesic
	 * calculations for the center point.
	 *
	 * @param tg
	 * @param g2d
	 * @param clipBounds
	 * @param converter
	 */
	static AddModifiersGeo(tg: TGLight, g2d: Graphics2D, clipBounds: Rectangle2D | Array<Point2D> | null, converter: IPointConversion): void;
	/**
	 * RFA, NFA, FFA need these for line spacing
	 *
	 * @param tg
	 * @return
	 */
	private static getRFALines;
	/**
	 * Added sector range fan modifiers based using the calculated orientation
	 * indicator points
	 *
	 * @param tg
	 * @param converter
	 * @return
	 */
	private static addSectorModifiers;
	/**
	 * Called by the renderer after tg.Pixels has been filled with the
	 * calculated points. The modifier path depends on points calculated by
	 * CELineArray.
	 *
	 * @param tg
	 */
	static AddModifiers2(tg: TGLight, converter: IPointConversion): void;
	/**
	 * Displays the tg modifiers using a client Graphics2D, this is an option
	 * provided to clients for displaying modifiers without using shapes
	 *
	 * @param tg the tactical graphic
	 * @param g2d the graphics object for drawing
	 * @deprecated
	 */
	static DisplayModifiers(tg: TGLight, g2d: Graphics2D): void;
	/**
	 * Returns a Shape object for the text background for labels and modifiers
	 *
	 * @param tg the tactical graphic object
	 * @param pt0 1st point of segment
	 * @param pt1 last point of segment
	 * @param stringWidth string width
	 * @param stringHeight string height
	 * @param lineFactor number of text lines above or below the segment
	 * @param isTextFlipped true if text is flipped
	 * @return the modifier shape
	 */
	static BuildModifierShape(tg: TGLight, pt0: POINT2, pt1: POINT2, stringWidth: int, stringHeight: int, lineFactor: double, isTextFlipped: boolean): Shape2;
	/**
	 * For BOUNDARY and other line types which require breaks for the integral
	 * text. Currently only boundary uses this
	 *
	 * @param tg
	 * @param g2d the graphics object for drawing
	 * @param shapes the shape array
	 */
	static GetIntegralTextShapes(tg: TGLight, g2d: Graphics2D, shapes: Array<Shape2>): void;
	private static switchDirection;
	/**
	 * Displays the modifiers to a Graphics2D from a BufferedImage
	 *
	 * @param tg the tactical graphic
	 * @param g2d the Graphic for drawing
	 * @param shapes the shape array
	 * @param isTextFlipped true if text is flipped
	 * @param converter to convert between geographic and pixel coordinates
	 */
	static DisplayModifiers2(tg: TGLight, g2d: Graphics2D, shapes: Array<Shape2>, isTextFlipped: boolean, converter: IPointConversion): void;
	/**
	 * Builds a shape object to wrap text
	 *
	 * @param g2d the Graphic object for drawing
	 * @param str text to wrap
	 * @param font the draw font
	 * @param tx the drawing transform, text rotation and translation
	 * @return
	 */
	static getTextShape(g2d: Graphics2D, str: string, font: Font, tx: AffineTransform): Shape;
	/**
	 * Creates text outline as a shape
	 *
	 * @param originalText the original text
	 * @return text shape
	 */
	static createTextOutline(originalText: Shape2): Shape2;
	/**
	 * Channels don't return points in tg.Pixels. For Channels modifiers we only
	 * need to collect the points, don't need internal arrays, and can calculate
	 * on which segments the modifiers lie.
	 *
	 * @param shape
	 * @return
	 */
	private static getShapePoints;
}
declare class TGLight {
	LatLongs: Array<POINT2>;
	private static readonly _className;
	get_LatLongs(): Array<POINT2>;
	set_LatLongs(value: Array<POINT2>): void;
	Pixels: Array<POINT2>;
	get_Pixels(): Array<POINT2>;
	set_Pixels(value: Array<POINT2>): void;
	modifiers: Array<Modifier2>;
	get_Modifiers(): Array<Modifier2>;
	set_Modifiers(value: Array<Modifier2>): void;
	protected tp: TexturePaint;
	set_TexturePaint(value: TexturePaint): void;
	get_TexturePaint(): TexturePaint;
	protected maskOff: boolean;
	constructor();
	private font;
	set_Font(value: Font): void;
	get_Font(): Font;
	private iconSize;
	/**
	 * Set the icon size for areas that have a symbol like LAA or Biological Contaminated Area
	 * @param pixelSize
	 */
	setIconSize(pixelSize: int): void;
	getIconSize(): int;
	private keepUnitRatio;
	set_KeepUnitRatio(value: boolean): void;
	get_KeepUnitRation(): boolean;
	private lineType;
	set_LineType(value: int): void;
	get_LineType(): int;
	private lineStyle;
	set_LineStyle(value: int): void;
	get_LineStyle(): int;
	private lineColor;
	get_LineColor(): Color | null;
	set_LineColor(value: Color | null): void;
	private fillStyle;
	get_FillStyle(): int;
	set_Fillstyle(value: int): void;
	private fillColor;
	get_FillColor(): Color | null;
	set_FillColor(value: Color | null): void;
	private fontBackColor;
	get_FontBackColor(): Color;
	set_FontBackColor(value: Color): void;
	private textColor;
	get_TextColor(): Color;
	set_TextColor(value: Color): void;
	private lineThickness;
	get_LineThickness(): int;
	set_LineThickness(value: int): void;
	private t;
	get_Name(): string;
	private client;
	get_Client(): string;
	set_client(value: string): void;
	set_Name(value: string): void;
	private t1;
	get_T1(): string;
	set_T1(value: string): void;
	private am;
	get_AM(): string;
	set_AM(value: string): void;
	private am1;
	get_AM1(): string;
	set_AM1(value: string): void;
	private an;
	get_AN(): string;
	set_AN(value: string): void;
	private v;
	get_V(): string;
	set_V(value: string): void;
	private ap;
	get_AP(): string;
	set_AP(value: string): void;
	private as;
	get_AS(): string;
	set_AS(value: string): void;
	private x;
	get_X(): string;
	set_X(value: string): void;
	private x1;
	get_X1(): string;
	set_X1(value: string): void;
	private h;
	get_H(): string;
	set_H(value: string): void;
	get_Location(): string;
	set_Location(value: string): void;
	private h1;
	/**
	 * @deprecated
	 */
	get_H1(): string;
	/**
	 * @deprecated
	 */
	set_H1(value: string): void;
	private y;
	private n;
	get_N(): string;
	set_N(value: string): void;
	private h2;
	/**
	 * @deprecated
	 */
	get_H2(): string;
	/**
	 * @deprecated
	 */
	set_H2(value: string): void;
	/**
	 * Only used for range fan
	 * left azimuth,right azimuth,min radius,max radius
	 */
	private leftRightMinMax;
	get_LRMM(): string;
	set_LRMM(value: string): void;
	private w;
	get_DTG(): string;
	set_DTG(value: string): void;
	private w1;
	get_DTG1(): string;
	set_DTG1(value: string): void;
	private standardIdentity;
	get_StandardIdentity(): string;
	/**
	 * @return true if standard identity is suspect/joker or hostile/faker
	 */
	isHostile(): boolean;
	private echelonSymbol;
	get_EchelonSymbol(): string;
	set_EchelonSymbol(value: string): void;
	private symbolId;
	get_SymbolId(): string;
	private status;
	get_Status(): string;
	set_Status(value: string): void;
	/**
	 * Sets tactical graphic properties based on the 20-30 digit Mil-Std-2525 symbol code
	 *
	 * @param value
	 */
	set_SymbolId(value: string): void;
	private visibleModifiers;
	/**
	 * @deprecated
	 */
	set_VisibleModifiers(value: boolean): void;
	/**
	 * @deprecated
	 */
	protected get_VisibleModifiers(): boolean;
	private visibleLabels;
	/**
	 * @deprecated
	 */
	set_VisibleLabels(value: boolean): void;
	/**
	 * @deprecated
	 */
	protected get_VisibleLabels(): boolean;
	protected _useLineInterpolation: boolean;
	get_UseLineInterpolation(): boolean;
	set_UseLineInterpolation(value: boolean): void;
	protected _useDashArray: boolean;
	get_UseDashArray(): boolean;
	set_UseDashArray(value: boolean): void;
	protected _useHatchFill: boolean;
	get_UseHatchFill(): boolean;
	set_UseHatchFill(value: boolean): void;
	private _wasClipped;
	set_WasClipped(value: boolean): void;
	get_WasClipped(): boolean;
	private _HideOptionalLabels;
	get_HideOptionalLabels(): boolean;
	set_HideOptionalLabels(value: boolean): void;
	private lineCap;
	set_lineCap(cap: int): void;
	get_lineCap(): int;
}
/**
 * Rendering class
 *
 *
 */
export declare class clsRenderer {
	private static readonly _className;
	/**
	 * Set tg geo points from the client points
	 *
	 * @param milStd
	 * @param tg
	 */
	private static setClientCoords;
	private static getClientCoords;
	/**
	 * Create MilStdSymbol from tactical graphic
	 *
	 * @deprecated
	 * @param tg tactical graphic
	 * @param converter geographic to pixels to converter
	 * @return MilstdSymbol object
	 */
	static createMilStdSymboFromTGLight(tg: TGLight, converter: IPointConversion): MilStdSymbol;
	/**
	 * Build a tactical graphic object from the client MilStdSymbol
	 *
	 * @param milStd MilstdSymbol object
	 * @param converter geographic to pixels converter
	 * @return tactical graphic
	 */
	static createTGLightFromMilStdSymbol(milStd: MilStdSymbol, converter: IPointConversion): TGLight;
	/**
	 * @deprecated @param milStd
	 * @param converter
	 * @param computeChannelPt
	 * @return
	 */
	static createTGLightFromMilStdSymbol(milStd: MilStdSymbol, converter: IPointConversion, computeChannelPt: boolean): TGLight;
	private static createAltitudeLabel;
	private static Shape2ToShapeInfo;
	/**
	 * Added function to handle when coords or display area spans IDL but not
	 * both, it prevents the symbol from rendering if the bounding rectangles
	 * don't intersect.
	 *
	 * @param tg
	 * @param converter
	 * @param clipArea
	 * @return
	 */
	static intersectsClipArea(tg: TGLight, converter: IPointConversion, clipArea: Point2D[] | Rectangle | Rectangle2D): boolean;
	/**
	 * Adds Feint, decoy, or dummy indicator to shapes. Does not check if tactical graphic should have indicator
	 */
	private static addFDI;
	/**
	 * GoogleEarth renderer uses polylines for rendering
	 *
	 * @param mss MilStdSymbol object
	 * @param converter the geographic to pixels coordinate converter
	 * @param clipArea the clip bounds
	 */
	static renderWithPolylines(mss: MilStdSymbol, converter: IPointConversion, clipArea: Point2D[] | Rectangle | Rectangle2D): void;
	/**
	 * @param mss
	 * @param converter
	 * @param clipArea
	 * @param g2d
	 * @deprecated Graphics2D not used
	 */
	static renderWithPolylines(mss: MilStdSymbol, converter: IPointConversion, clipArea: Point2D[] | Rectangle | Rectangle2D, g2d: Graphics2D): void;
	/**
	 * Google Earth renderer: Called by mapfragment-demo This is the public
	 * interface for Google Earth renderer assumes tg.Pixels is filled assumes
	 * the caller instantiated the ShapeInfo arrays
	 *
	 * @param tg tactical graphic
	 * @param shapeInfos symbol ShapeInfo array
	 * @param modifierShapeInfos modifier ShapeInfo array
	 * @param converter geographic to pixels coordinate converter
	 * @param clipArea clipping bounds in pixels
	 */
	static render_GE(tg: TGLight, shapeInfos: Array<ShapeInfo>, modifierShapeInfos: Array<ShapeInfo>, converter: IPointConversion, clipArea: Point2D[] | Rectangle | Rectangle2D): void;
	/**
	 * See render_GE below for comments
	 *
	 * @param tg
	 * @param shapeInfos
	 * @param modifierShapeInfos
	 * @param converter
	 * @param clipArea
	 * @param g2d test android-gradle
	 * @deprecated Graphics2D not used
	 */
	static render_GE(tg: TGLight, shapeInfos: Array<ShapeInfo>, modifierShapeInfos: Array<ShapeInfo>, converter: IPointConversion, clipArea: Point2D[] | Rectangle | Rectangle2D, g2d: Graphics2D): void;
	/**
	 * creates a shape for known symbols. The intent is to use client points for
	 * the shape and is intended for use with ellipse. If hatch &gt; 1 it creates 2 shapes
	 * one for the hatch pattern, the second one is for the outline.
	 *
	 * @param milStd
	 * @param ipc
	 * @param clipArea
	 * @param shapeType
	 * @param lineColor
	 * @param fillColor
	 * @param hatch
	 */
	static render_Shape(milStd: MilStdSymbol, ipc: IPointConversion, clipArea: Point2D[] | Rectangle | Rectangle2D, shapeType: int, lineColor: Color, fillColor: Color, hatch: int): void;
	/**
	 * to follow right hand rule for LC when affiliation is hostile. also fixes
	 * MSDZ point order and maybe various other wayward symbols
	 *
	 * @param tg
	 */
	private static setHostileLC;
	/**
	 * set the clip rectangle as an arraylist or a Rectangle2D depending on the
	 * object
	 *
	 * @param clipBounds
	 * @param clipRect
	 * @param clipArray
	 * @return
	 */
	private static setClip;
	/**
	 * public render function transferred from JavaLineArrayCPOF project. Use
	 * this function to replicate CPOF renderer functionality.
	 *
	 * @param mss the milStdSymbol object
	 * @param converter the geographic to pixels coordinate converter
	 * @param clipBounds the pixels based clip bounds
	 */
	static render(mss: MilStdSymbol, converter: IPointConversion, clipBounds: Rectangle2D | Array<Point2D> | null): void;
	/**
	 * Generic tester button says Tiger or use JavaRendererSample. Generic
	 * renderer testers: called by JavaRendererSample and TestJavaLineArray
	 * public render function transferred from JavaLineArrayCPOF project. Use
	 * this function to replicate CPOF renderer functionality.
	 *
	 * @param mss MilStdSymbol
	 * @param converter geographic to pixels converter
	 * @param shapeInfos ShapeInfo array
	 * @param modifierShapeInfos modifier ShapeInfo array
	 * @param clipBounds clip bounds
	 */
	static render(mss: MilStdSymbol, converter: IPointConversion, shapeInfos: Array<ShapeInfo>, modifierShapeInfos: Array<ShapeInfo>, clipBounds: Rectangle2D | Rectangle | Array<Point2D> | null): void;
	static getCMLineType(version: int, entityCode: int): int;
	/**
	 * Some symbol's points are reversed when moving from 2525C to 2525D. This method should be called at the start of each render.
	 *
	 * It's a simpler fix to reverse the points order at start than to reverse order when rendering.
	 *
	 * Note: Make sure to only call once to not reverse reversed points
	 * @param tg
	 */
	private static reversePointsRevD;
}
export declare class RendererUtilities {
	private static readonly OUTLINE_SCALING_FACTOR;
	static imgToBase64String(img: OffscreenCanvas): Promise<string>;
	private static pastIdealOutlineColors;
	/**
	 *
	 * @param color {String} color like "#FFFFFF"
	 * @return {String}
	 */
	static getIdealOutlineColor(color: Color): Color;
	/**
	 * Create a copy of the {@Color} object with the passed alpha value.
	 * @param color {@Color} object used for RGB values
	 * @param alpha {@float} value between 0 and 1
	 * @return
	 */
	static setColorAlpha(color: Color, alpha: float): Color;
	/**
	 *
	 * @param color
	 * @return 8 character hex code, will have to prepend '#' or '0x' depending on your usage
	 */
	private static ColorToHex;
	/**
	 *
	 * @param color
	 * @param withAlpha
	 * @return
	 */
	static colorToHexString(color: Color, withAlpha: boolean): string;
	/**
	 * Clients should use getTextBounds
	 * @param {String} fontName like "Arial" or "Arial, sans-serif" so a backup is
	 * available in case 'Arial' is not present.
	 * @param {Number} fontSize like 12
	 * @param {String} fontStyle like "bold"
	 * @param {String} text include if you want a width value.
	 * @param {OffscreenCanvasRenderingContext2D}
	 * @returns {Object} {width:Number,height:Number,descent:Number,fullHeight:Number}
	 */
	static measureText(fontName: string, fontSize: int, fontStyle: string, text: string, context: OffscreenCanvasRenderingContext2D | null): Rectangle2D;
	static measureText(font: string, text: string, context: OffscreenCanvasRenderingContext2D | null): Rectangle2D;
	static measureText(text: string, context: OffscreenCanvasRenderingContext2D): Rectangle2D;
	/**
	 *
	 * @param hexValue - String representing hex value (formatted "0xRRGGBB"
	 * i.e. "0xFFFFFF") OR formatted "0xAARRGGBB" i.e. "0x00FFFFFF" for a color
	 * with an alpha value I will also put up with "RRGGBB" and "AARRGGBB"
	 * without the starting "0x" or "#"
	 * @return
	 */
	static getColorFromHexString(hexValue: string): Color | null;
	/**
	 * For Renderer Use Only
	 * Assumes a fresh SVG String from the SVGLookup with its default values
	 * @param symbolID
	 * @param svg
	 * @param strokeColor hex value like "#FF0000";
	 * @param fillColor hex value like "#FF0000";
	 * @return SVG String
	 */
	static setSVGFrameColors(symbolID: string, svg: string, strokeColor: Color, fillColor: Color): string;
	static setSVGSPCMColors(symbolID: string, svg: string, strokeColor: Color, fillColor: Color): string;
	/**
	 * For Renderer Use Only
	 * Changes colors for single point control measures
	 * @param symbolID
	 * @param svg
	 * @param strokeColor hex value like "#FF0000";
	 * @param fillColor hex value like "#FF0000";
	 * @param isOutline true if this represents a thicker outline to render first beneath the normal symbol (the function must be called twice)
	 * @return SVG String
	 *
	 */
	static setSVGSPCMColors(symbolID: string, svg: string, strokeColor: Color, fillColor: Color, isOutline: boolean): string;
	static findWidestStrokeWidth(svg: string): float;
	static getDistanceBetweenPoints(pt1: Point2D, pt2: Point2D): int;
	static scaleIcon(symbolID: string, icon: SVGInfo): SVGInfo;
	static getData(path: string): Promise<any>;
}
/**
 * This class is used for rendering icons that represent the single point graphics in the MilStd 2525.
 * It can also be used for rendering icon previews for multipoint graphics.
 */
export declare class MilStdIconRenderer {
	private TAG;
	private static _instance;
	private _initSuccess;
	private _SPSVGR;
	private constructor();
	static getInstance(): MilStdIconRenderer;
	/**
	 *
	 *
	 */
	private init;
	isReady(): boolean;
	/**
	 * Checks symbol codes and returns whether they can be rendered.
	 * For multi-point graphics, modifiers are ignored because we don't need that
	 * information to show preview icons in the SymbolPicker.
	 *
	 * @param symbolID 20-30 digit 2525D Symbol ID Code
	 * @param attributes (currently unused)
	 * @return true if the basic form of the graphic can be rendered
	 */
	CanRender(symbolID: string, attributes: Map<string, string>): boolean;
	RenderSVG(symbolID: string, modifiers: Map<string, string>, attributes: Map<string, string>): SVGSymbolInfo | null;
	AddCustomSymbol(msInfo: MSInfo, svgInfo: SVGInfo): boolean;
}
/**
 * Main class for rendering multi-point graphics such as Control Measures, Atmospheric, and Oceanographic.
 *
 */
export declare class WebRenderer {
	static readonly OUTPUT_FORMAT_KML = 0;
	/**
	 * @deprecated
	 */
	static readonly OUTPUT_FORMAT_JSON = 1;
	static readonly OUTPUT_FORMAT_GEOJSON = 2;
	static readonly OUTPUT_FORMAT_GEOSVG = 3;
	static readonly MIN_ALT_DEFAULT: double;
	static readonly MAX_ALT_DEFAULT: double;
	static readonly RADIUS1_DEFAULT: double;
	static readonly RADIUS2_DEFAULT: double;
	static readonly LEFT_AZIMUTH_DEFAULT: double;
	static readonly RIGHT_AZIMUTH_DEFAULT: double;
	static readonly ERR_ATTRIBUTES_NOT_FORMATTED: string;
	static readonly DEFAULT_ATTRIBUTES: string;
	private static _initSuccess;
	private static init;
	/**\
		* Set minimum level at which an item can be logged.
		* In descending order:
		* OFF = Integer.MAX_VALUE
		* Severe = 1000
		* Warning = 900
		* Info = 800
		* Config = 700
		* Fine = 500
		* Finer = 400
		* Finest = 300
		* All = Integer.MIN_VALUE
		* Use like WebRenderer.setLoggingLevel(Level.INFO);
		* or
		* Use like WebRenderer.setLoggingLevel(800);
		*/
	static setLoggingLevel(level: LogLevel | int): void;
	/**
	 * Single Point Tactical Graphics are rendered from font files.
	 * The font size you specify here determines how big the symbols will
	 * be rendered.  This should be set once at startup.
	 * @param size
	 */
	static setTacticalGraphicPointSize(size: int): void;
	/**
	 * Units are rendered from font files.
	 * The font size you specify here determines how big the symbols will
	 * be rendered.  This should be set once at startup.
	 * @param size
	 */
	static setUnitPointSize(size: int): void;
	/**
	 * Modifier Text Color will by default match the line color.
	 * This will override all modifier text color.
	 * @param hexColor
	 */
	/**
	 * Renders all multi-point symbols, creating KML that can be used to draw
	 * it on a Google map.  Multipoint symbols cannot be draw the same
	 * at different scales. For instance, graphics with arrow heads will need to
	 * redraw arrowheads when you zoom in on it.  Similarly, graphics like a
	 * Forward Line of Troops drawn with half circles can improve performance if
	 * clipped when the parts of the graphic that aren't on the screen.  To help
	 * readjust graphics and increase performance, this function requires the
	 * scale and bounding box to help calculate the new locations.
	 * @param id A unique identifier used to identify the symbol by Google map.
	 * The id will be the folder name that contains the graphic.
	 * @param name a string used to display to the user as the name of the
	 * graphic being created.
	 * @param description a brief description about the graphic being made and
	 * what it represents.
	 * @param symbolCode A 20-30 digit symbolID corresponding to one of the
	 * graphics in the MIL-STD-2525D
	 * @param controlPoints The vertices of the graphics that make up the
	 * graphic.  Passed in the format of a string, using decimal degrees
	 * separating lat and lon by a comma, separating coordinates by a space.
	 * The following format shall be used "x1,y1[,z1] [xn,yn[,zn]]..."
	 * @param altitudeMode Indicates whether the symbol should interpret
	 * altitudes as above sea level or above ground level. Options are
	 * "clampToGround", "relativeToGround" (from surface of earth), "absolute"
	 * (sea level), "relativeToSeaFloor" (from the bottom of major bodies of
	 * water).
	 * @param scale A number corresponding to how many meters one meter of our
	 * map represents. A value "50000" would mean 1:50K which means for every
	 * meter of our map it represents 50000 meters of real world distance.
	 * @param bbox The viewable area of the map.  Passed in the format of a
	 * string "lowerLeftX,lowerLeftY,upperRightX,upperRightY." Not required
	 * but can speed up rendering in some cases.
	 * example: "-50.4,23.6,-42.2,24.2"
	 * @param modifiers {@link Map}, keyed using constants from Modifiers.
	 * Pass in comma delimited String for modifiers with multiple values like AM, AN &amp; X
	 * @param attributes {@link Map}, keyed using constants from MilStdAttributes.
	 * @param format An enumeration: 2 for GeoJSON.
	 * @return A JSON string representation of the graphic.
	 */
	static RenderSymbol(id: string, name: string, description: string, symbolCode: string, controlPoints: string, altitudeMode: string, scale: double, bbox: string, modifiers: Map<string, string>, attributes: Map<string, string>, format: int): string;
	/**
	 * Renders all multi-point symbols, creating KML or JSON for the user to
	 * parse and render as they like.
	 * This function requires the bounding box to help calculate the new
	 * locations.
	 * @param id A unique identifier used to identify the symbol by Google map.
	 * The id will be the folder name that contains the graphic.
	 * @param name a string used to display to the user as the name of the
	 * graphic being created.
	 * @param description a brief description about the graphic being made and
	 * what it represents.
	 * @param symbolCode A 20-30 digit symbolID corresponding to one of the
	 * graphics in the MIL-STD-2525D
	 * @param controlPoints The vertices of the graphics that make up the
	 * graphic.  Passed in the format of a string, using decimal degrees
	 * separating lat and lon by a comma, separating coordinates by a space.
	 * The following format shall be used "x1,y1 [xn,yn]..."
	 * @param pixelWidth pixel dimensions of the viewable map area
	 * @param pixelHeight pixel dimensions of the viewable map area
	 * @param bbox The viewable area of the map.  Passed in the format of a
	 * string "lowerLeftX,lowerLeftY,upperRightX,upperRightY."
	 * example: "-50.4,23.6,-42.2,24.2"
	 * @param modifiers {@link Map}, keyed using constants from Modifiers.
	 * Pass in comma delimited String for modifiers with multiple values like AM, AN &amp; X
	 * @param attributes {@link Map}, keyed using constants from MilStdAttributes.
	 * @param format An enumeration: 2 for GeoJSON.
	 * @return A JSON (1) or KML (0) string representation of the graphic.
	 */
	static RenderSymbol2D(id: string, name: string, description: string, symbolCode: string, controlPoints: string, pixelWidth: int, pixelHeight: int, bbox: string, modifiers: Map<string, string>, attributes: Map<string, string>, format: int): string;
	/**
	 * Renders all MilStd 2525 multi-point symbols, creating MilStdSymbol that contains the
	 * information needed to draw the symbol on the map.
	 * DOES NOT support RADARC, CAKE, TRACK etc...
	 * ArrayList&lt;Point2D&gt; milStdSymbol.getSymbolShapes[index].getPolylines()
	 * and
	 * ShapeInfo = milStdSymbol.getModifierShapes[index].
	 *
	 *
	 * @param id
	 *            A unique identifier used to identify the symbol by Google map.
	 *            The id will be the folder name that contains the graphic.
	 * @param name
	 *            a string used to display to the user as the name of the
	 *            graphic being created.
	 * @param description
	 *            a brief description about the graphic being made and what it
	 *            represents.
	 * @param symbolCode
	 *            A 20-30 digit symbolID corresponding to one of the graphics
	 *            in the MIL-STD-2525D
	 * @param controlPoints
	 *            The vertices of the graphics that make up the graphic. Passed
	 *            in the format of a string, using decimal degrees separating
	 *            lat and lon by a comma, separating coordinates by a space. The
	 *            following format shall be used "x1,y1[,z1] [xn,yn[,zn]]..."
	 * @param altitudeMode
	 *            Indicates whether the symbol should interpret altitudes as
	 *            above sea level or above ground level. Options are
	 *            "clampToGround", "relativeToGround" (from surface of earth),
	 *            "absolute" (sea level), "relativeToSeaFloor" (from the bottom
	 *            of major bodies of water).
	 * @param scale
	 *            A number corresponding to how many meters one meter of our map
	 *            represents. A value "50000" would mean 1:50K which means for
	 *            every meter of our map it represents 50000 meters of real
	 *            world distance.
	 * @param bbox
	 *            The viewable area of the map. Passed in the format of a string
	 *            "lowerLeftX,lowerLeftY,upperRightX,upperRightY." Not required
	 *            but can speed up rendering in some cases. example:
	 *            "-50.4,23.6,-42.2,24.2"
	 * @param modifiers
	 *            Used like:
	 *            modifiers.set(Modifiers.T_UNIQUE_DESIGNATION_1, "T");
	 *            Or
	 *            modifiers.set(Modifiers.AM_DISTANCE, "1000,2000,3000");
	 * @param attributes
	 * 			  Used like:
	 *            attributes.set(MilStdAttributes.LineWidth, "3");
	 *            Or
	 *            attributes.set(MilStdAttributes.LineColor, "#00FF00");
	 * @return MilStdSymbol
	 */
	static RenderMultiPointAsMilStdSymbol(id: string, name: string, description: string, symbolCode: string, controlPoints: string, altitudeMode: string, scale: double, bbox: string, modifiers: Map<string, string>, attributes: Map<string, string>): MilStdSymbol;
	/**
	 * Given a symbol code meant for a single point symbol, returns the
	 * anchor point at which to display that image based off the image returned
	 * from the URL of the SinglePointServer.
	 *
	 * @param symbolID - the 20-30 digit symbolID of a single point MilStd2525
	 * symbol.
	 * @return A pixel coordinate of the format "x,y".
	 * Returns an empty string if an error occurs.
	 * @deprecated
	 */
	getSinglePointAnchor(symbolID: string): string;
	/**
	 * Given a symbol code meant for a single point symbol, returns the
	 * anchor point at which to display that image based off the image returned
	 * from the URL of the SinglePointServer.
	 *
	 * @param symbolID - the 20-30 digit symbolID of a single point MilStd2525
	 * symbol.
	 * @return A pixel coordinate of the format "anchorX,anchorY,SymbolBoundsX,
	 * SymbolBoundsY,SymbolBoundsWidth,SymbolBoundsHeight,IconWidth,IconHeight".
	 * Anchor, represents the center point of the core symbol within the image.
	 * The image should be centered on this point.
	 * Symbol bounds represents the bounding rectangle of the core symbol within
	 * the image.
	 * IconWidth/Height represents the height and width of the image in its
	 * entirety.
	 * Returns an empty string if an error occurs.
	 * @deprecated
	 */
	static getSinglePointInfo(symbolID: string): string;
	/**
	 * Returns true if we recommend clipping a particular symbol.
	 * Would return false for and Ambush but would return true for a Line of
	 * Contact due to the decoration on the line.
	 * @param symbolID
	 * @return
	 */
	static ShouldClipMultipointSymbol(symbolID: string): string;
	/**
	* Given a symbol code meant for a single point symbol, returns the
	* symbol as a byte array.
	*
	* @param symbolID - the 20-30 digit symbolID of a single point MilStd2525
	* symbol.
	* @return byte array.
	 * @deprecated
	*/
	static getSinglePointByteArray(symbolID: string): null;
	/**
	 * Converts a rectangle with two points and a width to a polygon that contains the four corners of the rectangle
	 *
	 * @param endpoints the two end points of the rectangle
	 * @param width  the width of the rectangle
	 * @returns the points of a polygon containing the four points of a rectangle
	 */
	static getRectangleCorners(endpoints: string, width: number): string;
}
/**
 * Loads files needed by the renderer and initializes its data.
 * Required call before any rendering.
 * Must wait for the returned promise to resolve before any rendering.
 * @param location where renderer and asset files are location.  So if location is "127.0.0.1:8080/dist/C5Ren.js"
 * pass in "/dist/".  This is needed when all the files aren't in the same location.  When the renderer gets imported, it thinks it's
 * in the location of the file that imported it, not where it actually exists and then it can't find the asset files.  If location is not
 * set, the renderer assumes the json asset files are in the same location as where the C5Ren script is being run.
 */
export declare function initialize(location?: string): Promise<any>;
/**
 * Returns true if renderer files are loaded and initialized.
 * @returns boolean
 */
export declare function isReady(): boolean;

export {};
